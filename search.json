[
  {
    "objectID": "02_model/03_r_sampling.html",
    "href": "02_model/03_r_sampling.html",
    "title": "Sampling in R",
    "section": "",
    "text": "By default R offers less control over random sampling than python and commercial simulation software. It uses a single random number stream for all sampling and does not allow you to create individual random number streams (each with its own seed) for each sampling distribution.\n\nThis is not ideal for DES, and has a range of impacts. The one you will likely experience is additional noise between experiments due to this lack of control. Another way to describe this is that changes in sampling distribution parameters and particularly arrival rates may cause experiments to go out of sync where the same patients experience different activity duration and routing due to random sampling differences across scenarios rather than the systematic differences you have introduced in your experiments.\nThe result of this random noise is that typically you will need to run a lot more replications to carefully assess difference between experiments than if it were reduced/eliminated. It is also harder to debug experiments.\n\nThis notebook will:\n\nDemonstrate the shortcomings of a single random number stream and how noise is introduced between experiments.\nIllustrate that problem with a simple simmer model that varies arrival rates\nIntroduce up to 25 random streams for sampling using the SimEd R package.\n\n\n\n\nlibrary(simmer)\nlibrary(simmer.bricks)\nlibrary(magrittr)\nsuppressMessages(library(simEd))\nsuppressMessages(library(tidyr))\n\n\n\n\nTo illustrate the impact of this design consider the example below. Imagine we are going to simulate 5 patients length of stay (LoS) in an acute hospital followed by rehabilitation. Acute LoS is exponentially distribution while rehabilitation LoS follows a uniform distribution (the choice of distribution does not matter).\n\nIMPORTANT: To make the as results “repeatable” as possible we will set a random seed. With a single random stream we will see that this does not guarantee repeatable samples for patients between experiments.\n\n\n\n\nSEED &lt;- 42\nACUTE_MEAN &lt;- 32.0\nREHAB_MIN &lt;- 15.0\nREHAB_MAX &lt;- 80.0\n\n\n\n\n\nn_patients &lt;- 5\n\nset.seed(SEED)\nacute_los &lt;- rexp(n=n_patients, rate=1.0/ACUTE_MEAN)\nrehab_los &lt;- runif(n=n_patients, min=REHAB_MIN, max=REHAB_MAX)\n\nprint(acute_los)\n\n[1]  6.346778 21.148648  9.071713  1.222141 15.141652\n\nprint(rehab_los)\n\n[1] 23.75333 57.70450 60.82921 44.75322 61.74230\n\n\n\n\n\nWe will now reset the random stream using the same seed and limit the number of patients simulated to 2.\nWhen we re-run the code we might expect to get\n\nAcute Los:\n6.346778 21.148648\nRehab Los:\n23.75333 57.70450\n\nBut we will see that this does not happen. This is because all sampling makes use of a pseudo random number stream that generates uniformly distribution numbers \\(U\\)’s between 0 and 1. When only 1 stream is used for all sampling we can end up with lots of noise between experiments simply because different \\(U\\)’s are used for the same patients.\n\nn_patients &lt;- 2\n\nset.seed(SEED)\nacute_los &lt;- rexp(n=n_patients, rate=1.0/ACUTE_MEAN)\nrehab_los &lt;- runif(n=n_patients, min=REHAB_MIN, max=REHAB_MAX)\n\nprint(acute_los)\n\n[1]  6.346778 21.148648\n\nprint(rehab_los)\n\n[1] 56.71346 48.74124\n\n\n\n\n\n\nTo force the order of sampling within a single random number stream each patient must do their sampling upfront and in process order.\nBelow we re-run Experiments 1 and 2, but this time we make sure the process is sampled in order (acute then rehab) for each patient.\n\n\n\nn_patients &lt;- 3\n\nset.seed(SEED)\n\nfor (patient_i in 1:n_patients) {\n    print(paste(\"Patient \", patient_i))\n    print(paste(\"Acute \", rexp(n=1, rate=1.0/ACUTE_MEAN)))\n    print(paste(\"Rehab \", runif(n=1, min=REHAB_MIN, max=REHAB_MAX)))\n}\n\n[1] \"Patient  1\"\n[1] \"Acute  6.34677797708443\"\n[1] \"Rehab  68.9790956943762\"\n[1] \"Patient  2\"\n[1] \"Acute  9.07171320915222\"\n[1] \"Rehab  48.7412366934586\"\n[1] \"Patient  3\"\n[1] \"Acute  15.1416521370411\"\n[1] \"Rehab  23.7533288204577\"\n\n\n\n\n\n\nn_patients &lt;- 2\n\nset.seed(SEED)\n\nfor (patient_i in 1:n_patients) {\n    print(paste(\"Patient \", patient_i))\n    print(paste(\"Acute \", rexp(n=1, rate=1.0/ACUTE_MEAN)))\n    print(paste(\"Rehab \", runif(n=1, min=REHAB_MIN, max=REHAB_MAX)))\n}\n\n[1] \"Patient  1\"\n[1] \"Acute  6.34677797708443\"\n[1] \"Rehab  68.9790956943762\"\n[1] \"Patient  2\"\n[1] \"Acute  9.07171320915222\"\n[1] \"Rehab  48.7412366934586\"\n\n\n\n\n\n\nBy default simmer will be affected by the single random stream for all sampling. This is because in a DES there is no guarantee that sampling will not occur in process order like we saw above. The numbers generated will vary depending on when events are scheduled to take place.\nWe will first consider this in experiments where we set the exact number of arrivals to the model. In these experiments we will not use resources. This means that there is no impact on the model due to queuing if we increase or decrease the number of arrivals to the model.\n\n\n\n# set the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_1\", log_level=1) \n\n# setup simple patient trajectory\npatient &lt;- trajectory(\"patient_pathway\") %&gt;% \n  set_attribute(\"start_acute\", function() {now(env)}) %&gt;%\n  timeout(function() rexp(1, rate=1.0/ACUTE_MEAN)) %&gt;% \n  set_attribute(\"acute_los\", function() {now(env) - get_attribute(env, \"start_acute\")}) %&gt;%\n  log_(function() {paste(\"Acute LoS \", now(env) - get_attribute(env, \"start_acute\"))},\n       level=1) %&gt;%\n  set_attribute(\"start_rehab\", function() {now(env)}) %&gt;%\n  timeout(function() runif(n=1, min=REHAB_MIN, max=REHAB_MAX)) %&gt;% \n  set_attribute(\"rehab_los\", function() {now(env) - get_attribute(env, \"start_rehab\")}) %&gt;%\n  log_(function() {paste(\"Rehab LoS \", now(env) - get_attribute(env, \"start_rehab\"))},\n       level=1)\n\n\nenv %&gt;% \n  # add 5 arrivals all at the same time.\n  add_generator(\"patient\", patient, at(0, 0, 0, 0, 0)) %&gt;% \n  invisible\n \nenv %&gt;%\n  run() %&gt;% \n  invisible\n\n1.22214: patient3: Acute LoS  1.2221407443285\n6.34678: patient0: Acute LoS  6.34677797708443\n9.07171: patient2: Acute LoS  9.07171320915222\n15.1417: patient4: Acute LoS  15.1416521370411\n21.1486: patient1: Acute LoS  21.1486480683088\n24.9755: patient3: Rehab LoS  23.7533288204577\n59.8949: patient4: Rehab LoS  44.7532154561486\n64.0513: patient0: Rehab LoS  57.704498876119\n69.9009: patient2: Rehab LoS  60.8292109624017\n82.8909: patient1: Rehab LoS  61.7422963574063\n\n\n\n\n\nHere we setup the model to simulate 3 patients that all arrive as the unit opens. Arrival times are the same, so we may expect the acute and rehab lengths of stay to remain the same. However, we can see that the acute length of stay and rehab length of stay quickly goes out of sync i.e. we have introduced noise between experiments that is nothing to do with the variation in the number of patients (that we changed between experiments). Let’s take patient 0 as an example.\nIn experiment 1:\n\nAcute treatment is 6.3 days\nRehab treatment is 57.7 days\n\nIn experiment 2:\n\nAcute treatment is 6.3 days\nRehab treatment is 48.7 days\n\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_2\", log_level=1) \n\nenv %&gt;% \n  # now limit to 3 patients.\n  add_generator(\"patient\", patient, at(0, 0, 0)) %&gt;% \n  invisible\n \nenv %&gt;%\n  run() %&gt;% \n  invisible\n\n6.34678: patient0: Acute LoS  6.34677797708443\n9.07171: patient2: Acute LoS  9.07171320915222\n21.1486: patient1: Acute LoS  21.1486480683088\n44.902: patient1: Rehab LoS  23.7533288204577\n55.088: patient0: Rehab LoS  48.7412366934586\n71.95: patient2: Rehab LoS  62.8782404516824\n\n\n\n\n\n\nFinally we demonstrate that the effect is still observed across two experiments that vary the parameter of exponentially distributed inter-arrival times. We will run two new experiments. In the first IAT is 10 minutes. The second experiment increases the intensity of arrivals to an IAT of 2.0 minutes.\nThe function get_results_for_patient helps us trace patient 0 as they flowed through the model. The results illustratrate that the acute LoS remains the same, but the rehab LoS is different. As a single stream of random numbers was used, we were unable to control the order in which \\(U\\)’s were used to generate samples from the rehab L distributions.\n\n# helper function to process results \nget_results_for_patient &lt;- function(sim_env, patient_id){\n  results &lt;- subset(get_mon_attributes(sim_env), select = c(name, key, value))\n  results &lt;- spread(results, key, value)\n  return(results[results$name == patient_id,])\n}\n\n\n\n\nmean_iat = 10.0\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_simmer1\") \n\nenv %&gt;% \n  # expontially distr arrivals mean IAT = 10.0\n  add_generator(\"patient\", patient, function() rexp(1, rate=1.0/mean_iat),\n                mon=2) %&gt;% \n  invisible\n \nenv %&gt;%\n  run(90) %&gt;% \n  invisible\n\n\nresults_exp1 &lt;- get_results_for_patient(env, \"patient0\")\n\n\n\n\n\nmean_iat = 2.0\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_simmer2\")\n\nenv %&gt;% \n  # modify expontially distr arrivals to mean IAT = 9.0\n  add_generator(\"patient\", patient, function() rexp(1, rate=1.0/mean_iat),\n                mon=2) %&gt;% \n  invisible\n \nenv %&gt;%\n  run(90) %&gt;% \n  invisible\n\nresults_exp2 &lt;- get_results_for_patient(env, \"patient0\")\n\n\ncomparison &lt;- rbind(results_exp1, results_exp2)\ncomparison$name &lt;- c(\"Patient 0 in Exp1\", \"Patient 0 in Exp2\")\ncomparison\n\n               name acute_los rehab_los start_acute start_rehab\n1 Patient 0 in Exp1  9.071713  60.82921   1.9833681   11.055081\n2 Patient 0 in Exp2  9.071713  76.53344   0.3966736    9.468387\n\n\n\n\n\n\nsimEd is an R package aimed at improving simulation education. It makes use of a package called rstream that provides multiple random number streams for DES. simEd provides up to 25 streams and re-implements a useful selection of statistical distributions that can be used.\nDetails of the package can be found here: https://www.rdocumentation.org/packages/simEd/versions/2.0.1\n\nB. Lawson and L. M. Leemis, “An R package for simulation education,” 2017 Winter Simulation Conference (WSC), Las Vegas, NV, USA, 2017, pp. 4175-4186, doi: 10.1109/WSC.2017.8248124 https://ieeexplore.ieee.org/document/8248124\n\n\n\nThe code below re-implements the original experiments we conducted using simEd equivalent sampling functions. The main difference is that we prefix functions with v instead of r. For example rexp becomes vexp. We also introduce a third parameter called stream (settable 1:25).\nThis time when we reduce the number of patients from 5 to 2 the acute and rehab samples remain the same for the first two patients.\n\nn_patients &lt;- 5\n\nset.seed(SEED)\n# replace rexp with vexp and set stream number to 1\nacute_los &lt;- vexp(n=n_patients, rate=1.0/ACUTE_MEAN, stream=1)\n\n# replace runif with vunif and set stream number to 2\nrehab_los &lt;- vunif(n=n_patients, min=REHAB_MIN, max=REHAB_MAX, stream=2)\n\nprint(acute_los)\n\n[1]  0.4526612 13.6325644 29.0375715 38.6327714 24.0971868\n\nprint(rehab_los)\n\n[1] 79.39406 54.01103 59.64871 55.21520 36.20446\n\n\n\nn_patients &lt;- 2\n\nset.seed(SEED)\n# replace rexp with vexp and set stream number to 1\nacute_los &lt;- vexp(n=n_patients, rate=1.0/ACUTE_MEAN, stream=1)\n\n# replace runif with vunif and set stream number to 2\nrehab_los &lt;- vunif(n=n_patients, min=REHAB_MIN, max=REHAB_MAX, stream=2)\n\nprint(acute_los)\n\n[1]  0.4526612 13.6325644\n\nprint(rehab_los)\n\n[1] 79.39406 54.01103\n\n\n\n\n\nFinally we update the simmer model to use simEd and compare the results for patient 0 again. As expected we confirm that the sampling of acute and rehab duration is now in sync across the experiments.\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_1_simEd\") \n\n# redefine simple patient trajectory to use simEd variate functions\n# each distribution in the model has its own stream\npatient &lt;- trajectory(\"patient_pathway\") %&gt;% \n  set_attribute(\"start_acute\", function() {now(env)}) %&gt;%\n  timeout(function() vexp(1, rate=1.0/ACUTE_MEAN, stream=1)) %&gt;%  \n  set_attribute(\"acute_los\", function() {now(env) - get_attribute(env, \"start_acute\")}) %&gt;%\n  set_attribute(\"start_rehab\", function() {now(env)}) %&gt;%\n  timeout(function() vunif(n=1, min=REHAB_MIN, max=REHAB_MAX, stream=2)) %&gt;% \n  set_attribute(\"rehab_los\", function() {now(env) - get_attribute(env, \"start_rehab\")}) \n\nenv %&gt;% \n  # exponentially distr arrivals mean IAT = 10.0\n  add_generator(\"patient\", patient, function() vexp(1, rate=1.0/10.0, stream=3),\n                mon=2) %&gt;% \n  invisible\n \nenv %&gt;%\n  run(90) %&gt;% \n  invisible\n\n\n# store results for experiment 1 and patient 0\nresults_exp1 &lt;- get_results_for_patient(env, \"patient0\")\n\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_2_simEd\") \n\nenv %&gt;% \n  # exponentially distr arrivals mean IAT = 9.0\n  add_generator(\"patient\", patient, function() vexp(1, rate=1.0/2.0, stream=3),\n                mon=2) %&gt;% \n  invisible\n \nenv %&gt;%\n  run(90) %&gt;% \n  invisible\n\n# store results for experiment 2 and patient 0\nresults_exp2 &lt;- get_results_for_patient(env, \"patient0\")\n\n\n# updated comparison\ncomparison &lt;- rbind(results_exp1, results_exp2)\ncomparison$name &lt;- c(\"Patient 0 in Exp1\", \"Patient 0 in Exp2\")\ncomparison\n\n               name acute_los rehab_los start_acute start_rehab\n1 Patient 0 in Exp1 0.4526612  79.39406   2.2381819   2.6908430\n2 Patient 0 in Exp2 0.4526612  79.39406   0.4476364   0.9002976"
  },
  {
    "objectID": "02_model/03_r_sampling.html#imports",
    "href": "02_model/03_r_sampling.html#imports",
    "title": "Sampling in R",
    "section": "",
    "text": "library(simmer)\nlibrary(simmer.bricks)\nlibrary(magrittr)\nsuppressMessages(library(simEd))\nsuppressMessages(library(tidyr))"
  },
  {
    "objectID": "02_model/03_r_sampling.html#a-simple-motivating-example",
    "href": "02_model/03_r_sampling.html#a-simple-motivating-example",
    "title": "Sampling in R",
    "section": "",
    "text": "To illustrate the impact of this design consider the example below. Imagine we are going to simulate 5 patients length of stay (LoS) in an acute hospital followed by rehabilitation. Acute LoS is exponentially distribution while rehabilitation LoS follows a uniform distribution (the choice of distribution does not matter).\n\nIMPORTANT: To make the as results “repeatable” as possible we will set a random seed. With a single random stream we will see that this does not guarantee repeatable samples for patients between experiments.\n\n\n\n\nSEED &lt;- 42\nACUTE_MEAN &lt;- 32.0\nREHAB_MIN &lt;- 15.0\nREHAB_MAX &lt;- 80.0\n\n\n\n\n\nn_patients &lt;- 5\n\nset.seed(SEED)\nacute_los &lt;- rexp(n=n_patients, rate=1.0/ACUTE_MEAN)\nrehab_los &lt;- runif(n=n_patients, min=REHAB_MIN, max=REHAB_MAX)\n\nprint(acute_los)\n\n[1]  6.346778 21.148648  9.071713  1.222141 15.141652\n\nprint(rehab_los)\n\n[1] 23.75333 57.70450 60.82921 44.75322 61.74230\n\n\n\n\n\nWe will now reset the random stream using the same seed and limit the number of patients simulated to 2.\nWhen we re-run the code we might expect to get\n\nAcute Los:\n6.346778 21.148648\nRehab Los:\n23.75333 57.70450\n\nBut we will see that this does not happen. This is because all sampling makes use of a pseudo random number stream that generates uniformly distribution numbers \\(U\\)’s between 0 and 1. When only 1 stream is used for all sampling we can end up with lots of noise between experiments simply because different \\(U\\)’s are used for the same patients.\n\nn_patients &lt;- 2\n\nset.seed(SEED)\nacute_los &lt;- rexp(n=n_patients, rate=1.0/ACUTE_MEAN)\nrehab_los &lt;- runif(n=n_patients, min=REHAB_MIN, max=REHAB_MAX)\n\nprint(acute_los)\n\n[1]  6.346778 21.148648\n\nprint(rehab_los)\n\n[1] 56.71346 48.74124"
  },
  {
    "objectID": "02_model/03_r_sampling.html#force-the-order-of-sampling",
    "href": "02_model/03_r_sampling.html#force-the-order-of-sampling",
    "title": "Sampling in R",
    "section": "",
    "text": "To force the order of sampling within a single random number stream each patient must do their sampling upfront and in process order.\nBelow we re-run Experiments 1 and 2, but this time we make sure the process is sampled in order (acute then rehab) for each patient.\n\n\n\nn_patients &lt;- 3\n\nset.seed(SEED)\n\nfor (patient_i in 1:n_patients) {\n    print(paste(\"Patient \", patient_i))\n    print(paste(\"Acute \", rexp(n=1, rate=1.0/ACUTE_MEAN)))\n    print(paste(\"Rehab \", runif(n=1, min=REHAB_MIN, max=REHAB_MAX)))\n}\n\n[1] \"Patient  1\"\n[1] \"Acute  6.34677797708443\"\n[1] \"Rehab  68.9790956943762\"\n[1] \"Patient  2\"\n[1] \"Acute  9.07171320915222\"\n[1] \"Rehab  48.7412366934586\"\n[1] \"Patient  3\"\n[1] \"Acute  15.1416521370411\"\n[1] \"Rehab  23.7533288204577\"\n\n\n\n\n\n\nn_patients &lt;- 2\n\nset.seed(SEED)\n\nfor (patient_i in 1:n_patients) {\n    print(paste(\"Patient \", patient_i))\n    print(paste(\"Acute \", rexp(n=1, rate=1.0/ACUTE_MEAN)))\n    print(paste(\"Rehab \", runif(n=1, min=REHAB_MIN, max=REHAB_MAX)))\n}\n\n[1] \"Patient  1\"\n[1] \"Acute  6.34677797708443\"\n[1] \"Rehab  68.9790956943762\"\n[1] \"Patient  2\"\n[1] \"Acute  9.07171320915222\"\n[1] \"Rehab  48.7412366934586\""
  },
  {
    "objectID": "02_model/03_r_sampling.html#a-simmer-model",
    "href": "02_model/03_r_sampling.html#a-simmer-model",
    "title": "Sampling in R",
    "section": "",
    "text": "By default simmer will be affected by the single random stream for all sampling. This is because in a DES there is no guarantee that sampling will not occur in process order like we saw above. The numbers generated will vary depending on when events are scheduled to take place.\nWe will first consider this in experiments where we set the exact number of arrivals to the model. In these experiments we will not use resources. This means that there is no impact on the model due to queuing if we increase or decrease the number of arrivals to the model.\n\n\n\n# set the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_1\", log_level=1) \n\n# setup simple patient trajectory\npatient &lt;- trajectory(\"patient_pathway\") %&gt;% \n  set_attribute(\"start_acute\", function() {now(env)}) %&gt;%\n  timeout(function() rexp(1, rate=1.0/ACUTE_MEAN)) %&gt;% \n  set_attribute(\"acute_los\", function() {now(env) - get_attribute(env, \"start_acute\")}) %&gt;%\n  log_(function() {paste(\"Acute LoS \", now(env) - get_attribute(env, \"start_acute\"))},\n       level=1) %&gt;%\n  set_attribute(\"start_rehab\", function() {now(env)}) %&gt;%\n  timeout(function() runif(n=1, min=REHAB_MIN, max=REHAB_MAX)) %&gt;% \n  set_attribute(\"rehab_los\", function() {now(env) - get_attribute(env, \"start_rehab\")}) %&gt;%\n  log_(function() {paste(\"Rehab LoS \", now(env) - get_attribute(env, \"start_rehab\"))},\n       level=1)\n\n\nenv %&gt;% \n  # add 5 arrivals all at the same time.\n  add_generator(\"patient\", patient, at(0, 0, 0, 0, 0)) %&gt;% \n  invisible\n \nenv %&gt;%\n  run() %&gt;% \n  invisible\n\n1.22214: patient3: Acute LoS  1.2221407443285\n6.34678: patient0: Acute LoS  6.34677797708443\n9.07171: patient2: Acute LoS  9.07171320915222\n15.1417: patient4: Acute LoS  15.1416521370411\n21.1486: patient1: Acute LoS  21.1486480683088\n24.9755: patient3: Rehab LoS  23.7533288204577\n59.8949: patient4: Rehab LoS  44.7532154561486\n64.0513: patient0: Rehab LoS  57.704498876119\n69.9009: patient2: Rehab LoS  60.8292109624017\n82.8909: patient1: Rehab LoS  61.7422963574063\n\n\n\n\n\nHere we setup the model to simulate 3 patients that all arrive as the unit opens. Arrival times are the same, so we may expect the acute and rehab lengths of stay to remain the same. However, we can see that the acute length of stay and rehab length of stay quickly goes out of sync i.e. we have introduced noise between experiments that is nothing to do with the variation in the number of patients (that we changed between experiments). Let’s take patient 0 as an example.\nIn experiment 1:\n\nAcute treatment is 6.3 days\nRehab treatment is 57.7 days\n\nIn experiment 2:\n\nAcute treatment is 6.3 days\nRehab treatment is 48.7 days\n\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_2\", log_level=1) \n\nenv %&gt;% \n  # now limit to 3 patients.\n  add_generator(\"patient\", patient, at(0, 0, 0)) %&gt;% \n  invisible\n \nenv %&gt;%\n  run() %&gt;% \n  invisible\n\n6.34678: patient0: Acute LoS  6.34677797708443\n9.07171: patient2: Acute LoS  9.07171320915222\n21.1486: patient1: Acute LoS  21.1486480683088\n44.902: patient1: Rehab LoS  23.7533288204577\n55.088: patient0: Rehab LoS  48.7412366934586\n71.95: patient2: Rehab LoS  62.8782404516824"
  },
  {
    "objectID": "02_model/03_r_sampling.html#a-simmer-model-with-random-arrivals",
    "href": "02_model/03_r_sampling.html#a-simmer-model-with-random-arrivals",
    "title": "Sampling in R",
    "section": "",
    "text": "Finally we demonstrate that the effect is still observed across two experiments that vary the parameter of exponentially distributed inter-arrival times. We will run two new experiments. In the first IAT is 10 minutes. The second experiment increases the intensity of arrivals to an IAT of 2.0 minutes.\nThe function get_results_for_patient helps us trace patient 0 as they flowed through the model. The results illustratrate that the acute LoS remains the same, but the rehab LoS is different. As a single stream of random numbers was used, we were unable to control the order in which \\(U\\)’s were used to generate samples from the rehab L distributions.\n\n# helper function to process results \nget_results_for_patient &lt;- function(sim_env, patient_id){\n  results &lt;- subset(get_mon_attributes(sim_env), select = c(name, key, value))\n  results &lt;- spread(results, key, value)\n  return(results[results$name == patient_id,])\n}\n\n\n\n\nmean_iat = 10.0\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_simmer1\") \n\nenv %&gt;% \n  # expontially distr arrivals mean IAT = 10.0\n  add_generator(\"patient\", patient, function() rexp(1, rate=1.0/mean_iat),\n                mon=2) %&gt;% \n  invisible\n \nenv %&gt;%\n  run(90) %&gt;% \n  invisible\n\n\nresults_exp1 &lt;- get_results_for_patient(env, \"patient0\")\n\n\n\n\n\nmean_iat = 2.0\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_simmer2\")\n\nenv %&gt;% \n  # modify expontially distr arrivals to mean IAT = 9.0\n  add_generator(\"patient\", patient, function() rexp(1, rate=1.0/mean_iat),\n                mon=2) %&gt;% \n  invisible\n \nenv %&gt;%\n  run(90) %&gt;% \n  invisible\n\nresults_exp2 &lt;- get_results_for_patient(env, \"patient0\")\n\n\ncomparison &lt;- rbind(results_exp1, results_exp2)\ncomparison$name &lt;- c(\"Patient 0 in Exp1\", \"Patient 0 in Exp2\")\ncomparison\n\n               name acute_los rehab_los start_acute start_rehab\n1 Patient 0 in Exp1  9.071713  60.82921   1.9833681   11.055081\n2 Patient 0 in Exp2  9.071713  76.53344   0.3966736    9.468387"
  },
  {
    "objectID": "02_model/03_r_sampling.html#using-the-simed-package",
    "href": "02_model/03_r_sampling.html#using-the-simed-package",
    "title": "Sampling in R",
    "section": "",
    "text": "simEd is an R package aimed at improving simulation education. It makes use of a package called rstream that provides multiple random number streams for DES. simEd provides up to 25 streams and re-implements a useful selection of statistical distributions that can be used.\nDetails of the package can be found here: https://www.rdocumentation.org/packages/simEd/versions/2.0.1\n\nB. Lawson and L. M. Leemis, “An R package for simulation education,” 2017 Winter Simulation Conference (WSC), Las Vegas, NV, USA, 2017, pp. 4175-4186, doi: 10.1109/WSC.2017.8248124 https://ieeexplore.ieee.org/document/8248124\n\n\n\nThe code below re-implements the original experiments we conducted using simEd equivalent sampling functions. The main difference is that we prefix functions with v instead of r. For example rexp becomes vexp. We also introduce a third parameter called stream (settable 1:25).\nThis time when we reduce the number of patients from 5 to 2 the acute and rehab samples remain the same for the first two patients.\n\nn_patients &lt;- 5\n\nset.seed(SEED)\n# replace rexp with vexp and set stream number to 1\nacute_los &lt;- vexp(n=n_patients, rate=1.0/ACUTE_MEAN, stream=1)\n\n# replace runif with vunif and set stream number to 2\nrehab_los &lt;- vunif(n=n_patients, min=REHAB_MIN, max=REHAB_MAX, stream=2)\n\nprint(acute_los)\n\n[1]  0.4526612 13.6325644 29.0375715 38.6327714 24.0971868\n\nprint(rehab_los)\n\n[1] 79.39406 54.01103 59.64871 55.21520 36.20446\n\n\n\nn_patients &lt;- 2\n\nset.seed(SEED)\n# replace rexp with vexp and set stream number to 1\nacute_los &lt;- vexp(n=n_patients, rate=1.0/ACUTE_MEAN, stream=1)\n\n# replace runif with vunif and set stream number to 2\nrehab_los &lt;- vunif(n=n_patients, min=REHAB_MIN, max=REHAB_MAX, stream=2)\n\nprint(acute_los)\n\n[1]  0.4526612 13.6325644\n\nprint(rehab_los)\n\n[1] 79.39406 54.01103\n\n\n\n\n\nFinally we update the simmer model to use simEd and compare the results for patient 0 again. As expected we confirm that the sampling of acute and rehab duration is now in sync across the experiments.\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_1_simEd\") \n\n# redefine simple patient trajectory to use simEd variate functions\n# each distribution in the model has its own stream\npatient &lt;- trajectory(\"patient_pathway\") %&gt;% \n  set_attribute(\"start_acute\", function() {now(env)}) %&gt;%\n  timeout(function() vexp(1, rate=1.0/ACUTE_MEAN, stream=1)) %&gt;%  \n  set_attribute(\"acute_los\", function() {now(env) - get_attribute(env, \"start_acute\")}) %&gt;%\n  set_attribute(\"start_rehab\", function() {now(env)}) %&gt;%\n  timeout(function() vunif(n=1, min=REHAB_MIN, max=REHAB_MAX, stream=2)) %&gt;% \n  set_attribute(\"rehab_los\", function() {now(env) - get_attribute(env, \"start_rehab\")}) \n\nenv %&gt;% \n  # exponentially distr arrivals mean IAT = 10.0\n  add_generator(\"patient\", patient, function() vexp(1, rate=1.0/10.0, stream=3),\n                mon=2) %&gt;% \n  invisible\n \nenv %&gt;%\n  run(90) %&gt;% \n  invisible\n\n\n# store results for experiment 1 and patient 0\nresults_exp1 &lt;- get_results_for_patient(env, \"patient0\")\n\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_2_simEd\") \n\nenv %&gt;% \n  # exponentially distr arrivals mean IAT = 9.0\n  add_generator(\"patient\", patient, function() vexp(1, rate=1.0/2.0, stream=3),\n                mon=2) %&gt;% \n  invisible\n \nenv %&gt;%\n  run(90) %&gt;% \n  invisible\n\n# store results for experiment 2 and patient 0\nresults_exp2 &lt;- get_results_for_patient(env, \"patient0\")\n\n\n# updated comparison\ncomparison &lt;- rbind(results_exp1, results_exp2)\ncomparison$name &lt;- c(\"Patient 0 in Exp1\", \"Patient 0 in Exp2\")\ncomparison\n\n               name acute_los rehab_los start_acute start_rehab\n1 Patient 0 in Exp1 0.4526612  79.39406   2.2381819   2.6908430\n2 Patient 0 in Exp2 0.4526612  79.39406   0.4476364   0.9002976"
  },
  {
    "objectID": "02_model/01_model.html",
    "href": "02_model/01_model.html",
    "title": "Model code",
    "section": "",
    "text": "Note: we are calculating KPIs using our own code here, but you can also use simmer.plot. Help with install of simmer.plot (igraph installation is the actual issue) on Linux based systems: https://r.igraph.org/articles/installation-troubleshooting#cannot-compile-igraph-from-sources-on-linux\n\nIf you make use of conda environments (via Anaconda/mini-conda/mini-forge/mamba), remember to conda deactivate before installation.\n\n\n\nlibrary(simmer)\nlibrary(simmer.bricks)\nsuppressMessages(library(simmer.plot))\nlibrary(tibble)\nlibrary(ggplot2)\nsuppressMessages(library(RCurl))\nsuppressMessages(library(Rlab))\nsuppressMessages(library(dplyr))\nsuppressMessages(library(tidyr))\n\noptions(dplyr.summarise.inform = FALSE)"
  },
  {
    "objectID": "02_model/01_model.html#imports",
    "href": "02_model/01_model.html#imports",
    "title": "Model code",
    "section": "",
    "text": "Note: we are calculating KPIs using our own code here, but you can also use simmer.plot. Help with install of simmer.plot (igraph installation is the actual issue) on Linux based systems: https://r.igraph.org/articles/installation-troubleshooting#cannot-compile-igraph-from-sources-on-linux\n\nIf you make use of conda environments (via Anaconda/mini-conda/mini-forge/mamba), remember to conda deactivate before installation.\n\n\n\nlibrary(simmer)\nlibrary(simmer.bricks)\nsuppressMessages(library(simmer.plot))\nlibrary(tibble)\nlibrary(ggplot2)\nsuppressMessages(library(RCurl))\nsuppressMessages(library(Rlab))\nsuppressMessages(library(dplyr))\nsuppressMessages(library(tidyr))\n\noptions(dplyr.summarise.inform = FALSE)"
  },
  {
    "objectID": "02_model/01_model.html#default-values-and-constants",
    "href": "02_model/01_model.html#default-values-and-constants",
    "title": "Model code",
    "section": "2. Default values and constants",
    "text": "2. Default values and constants\n\n2.1 Distribution parameters\n\n#' Mean and Variance of the underlying Normal Distribution\n#' \n#' @description\n#' `normal_moments_from_lognormal` calculates the mu and sigma\n#' of the normal distribution underlying a lognormal\n#' mean and standard \n#'\n#' @details\n#' `rlnorm` from `stats` is designed to sample from the lognormal distribution. \n#' The parameters is expects are moments of the underlying normal distribution\n#' Using sample mean and standard deviation this function calculates \n#' the mu and sigma of the normal distribution. source: https://blogs.sas.com/content/iml/2014/06/04/simulate-lognormal-data-with-specified-mean-and-variance.html\n#' \n#' @param mean A number. Sample mean.\n#' @param stdev A number. Sample standard deviation\n#' @returns A list \nnormal_moments_from_lognormal &lt;- function(mean, std){\n  phi &lt;- sqrt(std^2 + mean^2)\n  mu &lt;- log(mean**2/phi)\n  sigma &lt;- sqrt(log(phi^2/mean^2))\n  return(list(\"mu\" = mu, \"sigma\" = sigma))\n}\n\n\n# sign-in/triage parameters\nDEFAULT_TRIAGE_MEAN &lt;- 3.0\n\n# registration parameters (lognormal distribution)\nDEFAULT_REG_PARAMS &lt;- normal_moments_from_lognormal(5.0, sqrt(2.0))\n\n# examination parameters\nDEFAULT_EXAM_PARAMS = list(mean=16.0, var=3.0)\n\n# trauma/stabilisation\nDEFAULT_TRAUMA_MEAN &lt;- 90.0\n\n# Trauma treatment (lognormal distribution)\nDEFAULT_TRAUMA_TREATMENT_PARAMS &lt;- normal_moments_from_lognormal(30.0, sqrt(4.0))\n\n# Non trauma treatment (lognormal distribution)\nDEFAULT_NON_TRAUMA_TREATMENT_PARAMS &lt;- normal_moments_from_lognormal(13.3, sqrt(2.0))\n\n# prob patient requires treatment given trauma\nDEFAULT_NON_TRAUMA_TREAT_P &lt;- 0.60\n\n# proportion of patients triaged as trauma\nDEFAULT_PROB_TRAUMA &lt;- 0.12\n\n\n\n2.2 Time dependent arrival rate data\nThe data for arrival rates varies between clinic opening at 6am and closure at 12am.\n\n# data are held in the Github repo and loaded from there.\nNSPP_PATH = 'https://raw.githubusercontent.com/TomMonks/open-science-for-sim/main/src/notebooks/01_foss_sim/data/ed_arrivals.csv'\n\ncsv_data &lt;- getURL(NSPP_PATH)\ndf &lt;- read.csv(text=csv_data)\n\n# lock in order of time of day for bar chart display\ndf$period &lt;- factor(df$period, levels = df$period)\n\nggplot(data=df, aes(x=period, y=arrival_rate)) +\n  geom_bar(stat=\"identity\", fill=\"steelblue\") + \n  theme(axis.text.x = element_text(angle = 90, \n                                   vjust = 0.5, \n                                   hjust=1)) +\n  xlab(\"Hour of day\") + \n  ylab(\"Mean arrivals (patients/hr)\")\n\n\n\n\n\n\n2.3 Resource Counts\nInteger count variables representing the number of resources at each activity in the process\n\nDEFAULT_N_TRIAGE &lt;- 1\nDEFAULT_N_REG &lt;- 1\nDEFAULT_N_EXAM &lt;- 3\n\n# stabilisation rooms\nDEFAULT_N_TRAUMA &lt;- 10000\n\n# Non-trauma cubicles\nDEFAULT_NON_TRAUMA_CUBICLES &lt;- 1\n\n# trauma pathway cubicles\nDEFAULT_TRAUMA_CUBICLES &lt;- 1\n\n\n\n2.4 Simulation model run settings\n\n# Random seed - this will be investigated for CRN\nSEED &lt;- 42\n\n# default results collection period\nDEFAULT_RESULTS_COLLECTION_PERIOD &lt;- 60 * 19\n\n# number of replications.\nDEFAULT_N_REPS &lt;- 5\n\n# Show the a trace of simulated events\n# 1 = show, 0 = do not show.\nLOG_LEVEL &lt;- 1"
  },
  {
    "objectID": "02_model/01_model.html#functions",
    "href": "02_model/01_model.html#functions",
    "title": "Model code",
    "section": "3. Functions",
    "text": "3. Functions\nLoad and format data\n\nload_arrival_data &lt;- function(path=NSPP_PATH){\n  csv_data &lt;- getURL(NSPP_PATH)\n  df &lt;- read.csv(text=csv_data)\n  \n  # arrivals per minute...\n  df$arrival_rate2 &lt;- df$arrival_rate/60.0\n  \n  # create 60 minute increments for period\n  df$period = seq(0, (nrow(df)-1)*60, by=60)\n  return(df)\n}\n\n\n#' Sample a patient type\n#' \n#' @description\n#' `sample_arrival_type` samples if a patient type is trauma or non-trauma\n#' with a given probability.\n#'\n#' @details\n#' The function uses the Bernouli distribution (Rlab) to sample\n#' if a patient is Trauma or Non-Trauma.  The return values are \n#' 1 = Trauma, 2 = Non-trauma.\n#' @param p A number: the probability a patient has trauma on arrival\nsample_arrival_type &lt;- function(p, n=1){\n  ifelse(rbern(n, prob = DEFAULT_PROB_TRAUMA) == 1, 1, 2)\n}\n\n\n#' Sample a if a non-trauma patient requires treatment\n#' \n#' @description\n#' `sample_nt_trauma_treatment` samples if a non-trauma patient\n#' requires cubicle treatment\n#'\n#' @details\n#' The function uses the Bernouli distribution (Rlab) to sample\n#' if a patient is requires treatment or not.  The return values are \n#' 1 = Treatment, 0 = No treatment\n#' @param p A number: The probability the patient requires treatment\nsample_nt_trauma_treatment &lt;- function(p){\n  ifelse(rbern(1, prob = p) == 1, 1, 0)\n}\n\nSampling from a non-stationary poisson process using thinning\n\nnspp_thinning &lt;- function(simulation_time, data, debug=FALSE){\n  \n  # calc time interval: assumes intervals are of equal length\n  interval &lt;- data$period[2] - data$period[1]\n  \n  # maximum arrival rate (smallest time between arrivals)\n  lambda_max &lt;- max(data$arrival_rate2)\n\n  while(TRUE){\n    # get time bucket (row of dataframe to use)\n    t &lt;- floor(simulation_time / interval) %% nrow(data) + 1\n    lambda_t &lt;- data$arrival_rate2[t]\n    \n    # set to a large number so that at least 1 sample is taken\n    u &lt;- Inf\n    rejects &lt;- -1\n    \n    # running total of time until next arrival\n    inter_arrival_time &lt;- 0.0\n    \n    # reject proportionate to lambda_t / lambda_max\n    ratio &lt;- lambda_t / lambda_max\n    while(u &gt;= ratio){\n      rejects &lt;- rejects + 1\n      # sample using max arrival rate\n      inter_arrival_time &lt;- inter_arrival_time + rexp(1, lambda_max)\n      u &lt;- runif(1, 0.0, 1.0)\n    }\n    \n    if(debug){\n      print({paste(\"Time:\", simulation_time, \n                   \" Rejections:\", rejects, \n                   \" t:\", t, \n                   \" lambda_t:\", lambda_t, \n                   \" IAT:\", inter_arrival_time)})\n    }\n      \n    return(inter_arrival_time)\n  }\n}"
  },
  {
    "objectID": "02_model/01_model.html#model-parameterisation",
    "href": "02_model/01_model.html#model-parameterisation",
    "title": "Model code",
    "section": "4. Model parameterisation",
    "text": "4. Model parameterisation\nThe model is setup to be created from a set of functions that return trajectories. Each function accepts a list that contains all parameters to configure the simulation model. Here we create the list and pre-populate it using default values.\n\ncreate_experiment &lt;- function(n_triage_bays=DEFAULT_N_TRIAGE,\n                              n_reg_clerks=DEFAULT_N_REG,\n                              n_exam_rooms=DEFAULT_N_EXAM,\n                              n_trauma_rooms=DEFAULT_N_TRAUMA,\n                              n_non_trauma_cubicles=DEFAULT_NON_TRAUMA_CUBICLES,\n                              n_trauma_cubicles=DEFAULT_TRAUMA_CUBICLES,\n                              triage_mean=DEFAULT_TRIAGE_MEAN,\n                              stabilisation_mean=DEFAULT_TRAUMA_MEAN,\n                              trauma_treat_params=DEFAULT_TRAUMA_TREATMENT_PARAMS,\n                              reg_params=DEFAULT_REG_PARAMS,\n                              exam_params=DEFAULT_EXAM_PARAMS,\n                              prob_non_trauma_treat=DEFAULT_NON_TRAUMA_TREAT_P,\n                              nontrauma_treat_params=DEFAULT_NON_TRAUMA_TREATMENT_PARAMS,\n                              prob_trauma=DEFAULT_PROB_TRAUMA,\n                              arrival_data_path=NSPP_PATH,\n                              log_level=LOG_LEVEL) {\n  \n  # load arrival data\n  arrival_data &lt;- load_arrival_data(path=arrival_data_path)\n  \n  # create list of parameters\n  experiment &lt;- list(n_triage_bays=n_triage_bays,\n                    n_reg_clerks=n_reg_clerks,\n                    n_exam_rooms=n_exam_rooms,\n                    n_trauma_rooms=n_trauma_rooms,\n                    n_non_trauma_cubicles=n_non_trauma_cubicles,\n                    n_trauma_cubicles=n_trauma_cubicles,\n                    triage_mean=triage_mean,\n                    stabilisation_mean=stabilisation_mean,\n                    trauma_treat_params=trauma_treat_params,\n                    reg_params=reg_params,\n                    exam_params=exam_params,\n                    prob_non_trauma_treat=prob_non_trauma_treat,\n                    nontrauma_treat_params=nontrauma_treat_params,\n                    prob_trauma=prob_trauma,\n                    arrival_data=arrival_data,\n                    log_level=log_level)\n  \n  return(experiment)\n}"
  },
  {
    "objectID": "02_model/01_model.html#patient-trajectories",
    "href": "02_model/01_model.html#patient-trajectories",
    "title": "Model code",
    "section": "5. Patient Trajectories",
    "text": "5. Patient Trajectories\nThe DES package simmer uses the concept of a trajectory to model a process for a particular patient type. In the urgent care centre example trajectories allow us to model separate trauma and non-trauma processes. Note that different trajectories can share common resources.\nThe simmer terminology for using resources and engaging in activities is easy to read:\n\nseize - queue and take a resource when it is available.\ntimeout - a process delay (e.g. treatment or diagnostics)\nrelease - release a resource.\n\nsimmer also provides a way to set an attribute of the trajectory using set_attribute. This is useful for storing timing information to display in a log: for example when a patient begins waiting for a resource (access via now(env)).\n\nImportant notes:\n\nThe function log_ is used in combination with function() paste to provide a dynamic simulation trace to the R console.\nSampling code should look as follows:\n\ntimeout(task = function() rexp(1, 3.0)) %&gt;%\n\nThe keyword function() must be included for dynamic sampling for each patient. Omitting function() means that it is evaluated once at the time the trajectory is created.\n\n\n\n5.1. Trauma Patients\n\nWe wrap the trajectory in a function called create_trauma_pathway. This allows us to pass an argument exp that can parameterise the trajectory for use in a discrete experiment.\n\n\ncreate_trauma_pathway &lt;- function(exp){\n    \n    trauma_pathway &lt;- trajectory(name=\"trauma_pathway\") %&gt;%\n      set_attribute(\"patient_type\", 1) %&gt;%\n      # log patient arrival\n      log_(function() {paste(\"**Trauma arrival\")}, level=1) %&gt;% \n      \n      # triage \n      set_attribute(\"start_triage_wait\", function() {now(exp$env)}) %&gt;%\n      visit(\"triage_bay\", function() rexp(1, 1/exp$triage_mean)) %&gt;%\n      log_(function() {paste(\"(T) Triage wait time:\",\n                       now(exp$env) - get_attribute(exp$env, \"start_triage_wait\"))},\n           level=1) %&gt;%\n      \n      # request trauma room for stabilization\n      set_attribute(\"start_trauma_room_wait\", function() {now(exp$env)}) %&gt;%\n      visit(\"trauma_room\", function() rexp(1, 1/exp$stabilisation_mean)) %&gt;%\n      log_(function() {paste(\"(T) Trauma room wait time:\",\n                       now(exp$env) - get_attribute(exp$env, \"start_trauma_room_wait\"))},\n           level=1) %&gt;%\n      \n      # request treatment cubicle\n      set_attribute(\"start_trauma_treat_wait\", function() {now(exp$env)}) %&gt;%\n      visit(\"trauma_treat_cubicle\", function() rlnorm(1, exp$trauma_treat_params$mu,\n                                                      exp$trauma_treat_params$sigma)) %&gt;%\n      log_(function() {paste(\"********************(T) Trauma treatment cubicle wait time:\",\n                       now(exp$env) - get_attribute(exp$env, \"start_trauma_treat_wait\"))},\n           level=1) %&gt;% \n    \n      # store the total time in system \n      set_attribute(\"total_time\", \n                    function() {now(exp$env) - get_attribute(exp$env, \"start_triage_wait\")})\n    \n  return(trauma_pathway)\n}\n\n\n\n5.2 Non-trauma patients\n\ncreate_nt_cubicle_treatment &lt;- function(exp){\n\n  nt_cubicle_treatment &lt;- trajectory() %&gt;% \n    log_(function() {paste(\"NT patient requirement treatment\")},\n         level=1) %&gt;% \n    seize(resource=\"nontrauma_treat_cubicle\", amount=1) %&gt;% \n    \n    timeout(task = function() rlnorm(1, exp$nontrauma_treat_params$mu,                                                     exp$nontrauma_treat_params$sigma)) %&gt;%\n    release(resource = \"nontrauma_treat_cubicle\", amount = 1) %&gt;% \n    log_(function() {paste(\"NT treatment complete\")},\n     level=1) %&gt;% \n  return(nt_cubicle_treatment)\n}\n\n\ncreate_non_trauma_pathway &lt;- function(exp){\n  # log messages\n  ARRIVAL_MSG = \"**Non-Trauma arrival**\"\n  TRIAGE_MSG = \"(NT) Triage wait time:\"\n  REG_MSG = \"Reg wait time:\"\n  EXAM_MSG = \"Exam wait time:\"\n  EXIT_MSG = \"NT Total time in system:\"\n  \n  # optional trajectory for proportion of patients that requirement treatment\n  nt_cubicle_treatment &lt;- create_nt_cubicle_treatment(exp)\n  \n  non_trauma_pathway &lt;- trajectory(name=\"non_trauma_pathway\") %&gt;%\n    set_attribute(\"patient_type\", 2) %&gt;%\n    # log non_trauma arrival\n    log_(function() {paste(ARRIVAL_MSG)}, level=1) %&gt;% \n    \n    # store start of waiting time for log calculations\n    set_attribute(\"start_triage_wait\", function() {now(exp$env)}) %&gt;%\n    # queue and use triage bay\n    visit(\"triage_bay\", function() rexp(1, 1/exp$triage_mean)) %&gt;%\n    log_(function() {paste(TRIAGE_MSG, now(exp$env) - get_attribute(exp$env, \"start_triage_wait\"))},\n         level=1) %&gt;%\n    \n    # queue and use registration clerk\n    set_attribute(\"start_reg_wait\", function() {now(exp$env)}) %&gt;%\n    visit(\"registration_clerk\", function() rlnorm(1, exp$reg_params$mu, \n                                                  exp$reg_params$sigma)) %&gt;%\n    log_(function() {paste(REG_MSG, now(exp$env) - get_attribute(exp$env, \"start_reg_wait\"))},\n         level=1) %&gt;%\n    \n    # queue and use examination room\n    set_attribute(\"start_exam_wait\", function() {now(exp$env)}) %&gt;%\n    visit(\"examination_room\",  function() rnorm(1, exp$exam_params$mean, \n                                                sqrt(exp$exam_params$var))) %&gt;%\n    log_(function() {paste(EXAM_MSG, now(exp$env) - get_attribute(exp$env, \"start_exam_wait\"))},\n         level=1) %&gt;%\n    \n    # a Proportion of patients require treatment in a cubicle\n    branch (\n      function() sample_nt_trauma_treatment(exp$prob_non_trauma_treat), continue=T,\n      nt_cubicle_treatment\n    ) %&gt;% \n    log_(function() {paste(EXIT_MSG, now(exp$env) - get_attribute(exp$env, \"start_triage_wait\"))},\n         level=1) %&gt;% \n    # store the total time in system \n    set_attribute(\"total_time\", \n                    function() {now(exp$env) - get_attribute(exp$env, \"start_triage_wait\")})\n  \n  return(non_trauma_pathway)\n}"
  },
  {
    "objectID": "02_model/01_model.html#modelling-patient-arrivals",
    "href": "02_model/01_model.html#modelling-patient-arrivals",
    "title": "Model code",
    "section": "6. Modelling patient arrivals",
    "text": "6. Modelling patient arrivals\nPatients arrive a the urgent treatment centre following a time dependent process. When patients arrive they are classified as trauma or non-trauma.\nTo modify the classification of patients we will use a trajectory that uses the `branch` function from simmer.\nThe function `sample_arrival_type` returns a 1 (trauma) or 2 (non-trauma). This is used to select the appropriate patient trajectory.\n\ncreate_arrival_generator &lt;- function(exp){\n  \n  DEPART_MSG &lt;- \"A patient has departed the UTC\"\n  \n  # create and parameterise the trauma pathway trajectory\n  trauma_pathway &lt;- create_trauma_pathway(exp)\n  \n  # create and parameterise the non-trauma pathway trajectory\n  non_trauma_pathway &lt;- create_non_trauma_pathway(exp)\n  \n  patient_arrival &lt;- trajectory() %&gt;%\n    branch(\n      function() sample_arrival_type(exp$prob_trauma), continue=T,\n        trauma_pathway,\n        non_trauma_pathway\n    ) %&gt;%\n    log_(function() {paste(DEPART_MSG)},level=1) %&gt;% \n    set_attribute(\"departed\", 1)\n  \n  return(patient_arrival)\n}"
  },
  {
    "objectID": "02_model/01_model.html#single-run-of-the-model",
    "href": "02_model/01_model.html#single-run-of-the-model",
    "title": "Model code",
    "section": "7. Single run of the model",
    "text": "7. Single run of the model\n\nWork in progress\n\n\nsingle_run &lt;- function(env, exp, \n                       rep_number=1, \n                       run_length=DEFAULT_RESULTS_COLLECTION_PERIOD, \n                       debug_arrivals=FALSE){\n  # add the simmer environment to the experiment list.\n  exp &lt;- c(exp, env=env) \n  \n  # Create the arrivals generator\n  arrival_gen &lt;- create_arrival_generator(exp)\n  \n  # create model and run.\n  env %&gt;% \n    add_resource(\"triage_bay\", exp$n_triage_bays) %&gt;%\n    add_resource(\"registration_clerk\", exp$n_reg_clerks) %&gt;%\n    add_resource(\"examination_room\", exp$n_exam_rooms) %&gt;%\n    add_resource(\"trauma_room\", exp$n_trauma_rooms) %&gt;%\n    add_resource(\"trauma_treat_cubicle\", exp$n_trauma_cubicles) %&gt;%\n    add_resource(\"nontrauma_treat_cubicle\", exp$n_non_trauma_cubicles) %&gt;%\n    add_generator(\"Patient\", arrival_gen, \n                  function() nspp_thinning(now(env), exp$arrival_data, \n                                           debug=debug_arrivals),\n                  mon=2) %&gt;% \n    run(until=run_length)\n  \n  # return environment and all of its results.\n  return(env)\n}\n\nScript to conduct single run of the model\n\nNote that the environment is created outside of the single_run function. This is to separate the creation of the environment from the run function call. The reason is so that the now(env) function will work correctly in the nspp_thinning sampling function (if we do not separate then the same time is always passed to the function).\n\n\nset.seed(SEED)\nexp &lt;- create_experiment(log_level=0)\ntreat_sim &lt;- simmer(\"TreatSim\", log_level=exp$log_level)\ntreat_sim &lt;- single_run(treat_sim, exp)\nprint(\"Simulation Complete.\")\n\n[1] \"Simulation Complete.\""
  },
  {
    "objectID": "02_model/01_model.html#multiple-replications",
    "href": "02_model/01_model.html#multiple-replications",
    "title": "Model code",
    "section": "8. Multiple replications",
    "text": "8. Multiple replications\n\nN_REPS &lt;- 50\n\nset.seed(42)\n\n# note unlike in simmer documentation we use a traditional for loop\n# instead of lapply. This allows us to separate env creation\n# from run and preserve the environment interaction between NSPP \n# and current sim time.\n# TO DO: look again -&gt; can treat_sim be created inside single_run()\nprint(\"running replications...\")\n\n[1] \"running replications...\"\n\nreps = vector()\nfor(rep in 1:N_REPS){\n  exp &lt;- create_experiment(log_level=0)\n  treat_sim &lt;- simmer(\"TreatSim\", log_level=exp$log_level)\n  treat_sim &lt;- single_run(treat_sim, exp)\n  # store the latest simulation enviornment and its results.\n  reps &lt;- c(reps, treat_sim)\n}\nprint(\"Complete.\")\n\n[1] \"Complete.\""
  },
  {
    "objectID": "02_model/01_model.html#results-analysis",
    "href": "02_model/01_model.html#results-analysis",
    "title": "Model code",
    "section": "9. Results analysis",
    "text": "9. Results analysis\nAnalysis of simmer results is achieved using a mix of statistics collected automatically and custom attributes set by the modeller during the run.\nIn general, we follow a typical strategy in a simulation study. We calculate the mean Key Performance Indicator (KPI) seen during an individual replication of the model (e.g. waiting time for triage and utilisation of the the triage rooms). This is repeated for all replications and the distribution of results can be visualised or we use a summary measure such as the mean.\nBelow we construct a summary table of results providing the mean of 16 KPIs.\n\nCode quality is a work in progress. 😃\n\n\narrivals_by_replication &lt;- function(envs){\n  results &lt;- vector()\n  for(env in envs){\n    results &lt;- c(results, get_n_generated(env, \"Patient\"))\n  }\n  return(data.frame(results))\n}\n\n\nget_resource_counts &lt;- function(exp) {\n  resource = c(\"triage_bay\", \n                \"registration_clerk\", \n                \"examination_room\",\n                \"trauma_room\",\n                \"trauma_treat_cubicle\",\n                \"nontrauma_treat_cubicle\")\n  \n  resource_counts = c(exp$n_triage_bays,\n                      exp$n_reg_clerks,\n                      exp$n_exam_rooms,\n                      exp$n_trauma_rooms,\n                      exp$n_trauma_cubicles,\n                      exp$n_non_trauma_cubicles)\n  \n  df_resource &lt;- data.frame(resource)\n  df_resource$count &lt;- resource_counts\n  return(df_resource)\n}\n\nFunctions to calculate KPIs from custom attributes\n\n# mean time in the system and throughput\ncalc_kpi_from_attributes_for_rep &lt;- function(rep){\n  \n  # get attributes\n  att &lt;- get_mon_attributes(reps)\n  # for speed - limit to replication number.\n  rep_att &lt;- subset(att[att$replication == rep,], select = c(name, key, value))\n  # long to wide format...\n  data_wide &lt;- spread(rep_att, key, value)\n  \n  # Patient type 1: trauma\n  # take the mean and ignore patients still in pathway\n  mean_time_1 = mean(data_wide[data_wide$patient_type == 1,]$total_time, na.rm = TRUE)\n  \n  # Patient type 2: non_trauma\n  # take the mean and ignore patients still in pathway\n  mean_time_2 = mean(data_wide[data_wide$patient_type == 2,]$total_time, na.rm = TRUE)\n  \n  # Throughput - discharges during opening hours.\n  throughput &lt;- sum(data_wide$departed, na.rm=TRUE)\n  \n  # store and return data.frame of results\n  rep_results &lt;- data.frame(\"05_total_time(non-trauma)\" = mean_time_2,\n                            \"08_total_time(trauma)\" = mean_time_1, \n                            \"09_throughput\"= throughput)\n  return(rep_results)\n}\n\ncalc_kpi_from_attributes &lt;- function(){\n  # calcs total time by patient type and total throughput\n  \n  # empty dataframe for attribute calculations.\n  att_results &lt;- data.frame(matrix(ncol = 3, nrow = 0))\n  colnames(att_results) &lt;- c(\"05_total_time(non-trauma)\", \"08_total_time(trauma)\", \"09_throughput\")\n\n  # add each rep separately as this works faster with pivot\n  for(rep in 1:N_REPS){\n    att_results &lt;- rbind(att_results, calc_kpi_from_attributes_for_rep(rep))\n  }\n\n  # return the KPIs by replications\n  return(att_results)\n}\n\n\ncreate_summary_table &lt;- function(reps, exp, dp=2){\n\n  # mean number of arrivals\n  arrival_counts &lt;- arrivals_by_replication(reps)\n  mean_arrivals &lt;- mean(arrival_counts$results)\n  arrival_df &lt;- data.frame(\"00_arrivals\", mean_arrivals)\n  names(arrival_df)&lt;-c(\"kpi\",\"mean\")\n\n  \n  # get results dataframe broken down by resource and replication.\n  arrivals &lt;- get_mon_arrivals(reps, per_resource=TRUE)\n  \n  # calculate waiting time\n  arrivals$waiting_time &lt;-arrivals$end_time - arrivals$start_time - arrivals$activity_time\n  # arrivals$waiting_time &lt;- round(arrivals$waiting_time, 2)\n  \n  cols &lt;- c(\"resource\", \"replication\")\n  summary_wait &lt;- arrivals %&gt;%\n    # mean waiting time in each replication\n    group_by(across(all_of(cols))) %&gt;%\n    summarise(rep_waiting_time=mean(waiting_time)) %&gt;% \n    # mean waiting time across replications\n    group_by(resource) %&gt;% \n    summarise(mean=mean(rep_waiting_time)) %&gt;% \n    mutate(resource=recode(resource,  \n                         'triage_bay'='01a_triage_wait', \n                         'registration_clerk'='02a_registration_wait',\n                         'examination_room'='03a_examination_wait',\n                         'nontrauma_treat_cubicle'='04a_treatment_wait(non_trauma)',\n                         'trauma_room'='06a_stabilisation_wait',\n                         'trauma_treat_cubicle'='07a_treatment_wait(trauma)')) %&gt;% \n    arrange(resource)\n  \n  \n  names(summary_wait)&lt;-c(\"kpi\",\"mean\")\n  \n  # utilisation calculation:\n  # simple calculation of total busy time / total scheduled resource time.\n  # where total scheduled time = n_resource * results collection period.\n  summary_util &lt;- arrivals %&gt;%\n    # mean waiting time in each replication\n    group_by(across(all_of(cols))) %&gt;%\n    summarise(in_use=sum(activity_time)) %&gt;% \n    arrange(resource)\n  \n  # add resource counts to table for calc\n  summary_util &lt;- merge(summary_util, get_resource_counts(exp), \n                        by=\"resource\", all=TRUE)\n  \n  # total in use / total scheduled time\n  summary_util$util = summary_util$in_use / (DEFAULT_RESULTS_COLLECTION_PERIOD * summary_util$count)  \n  \n  summary_util &lt;- summary_util %&gt;%\n    # mean waiting time in each replication\n    group_by(resource) %&gt;%\n    summarise(mean=mean(util)) %&gt;% \n    mutate(resource=recode(resource,  \n                         'triage_bay'='01b_triage_util', \n                         'registration_clerk'='02b_registration_util',\n                         'examination_room'='03b_examination_util',\n                         'nontrauma_treat_cubicle'='04b_treatment_util(non_trauma)',\n                         'trauma_room'='06b_stabilisation_util',\n                         'trauma_treat_cubicle'='07b_treatment_util(trauma)')) %&gt;% \n    arrange(resource)\n\n  names(summary_util) &lt;- c(\"kpi\",\"mean\")\n  \n  overall &lt;- bind_rows(arrival_df, summary_wait, summary_util) %&gt;% \n    arrange(kpi) \n  \n  ## KPIs calculated from attributes\n  # empty dataframe for attribute calculations.\n  att_results &lt;- calc_kpi_from_attributes()\n  mean_att_results &lt;- colMeans(att_results)\n\n  overall &lt;- overall %&gt;%\n    add_row(kpi=\"05_total_time(non-trauma)\", mean=mean_att_results[1]) %&gt;%\n    add_row(kpi=\"08_total_time(trauma)\", mean=mean_att_results[2]) %&gt;%\n    add_row(kpi=\"09_throughput\", mean=mean_att_results[3]) %&gt;%\n    arrange(kpi)\n  \n  # round and return\n  overall$mean &lt;- round(overall$mean, dp)\n  return(overall)\n}\n\n\nresults_summary &lt;- create_summary_table(reps, exp)\nresults_summary\n\n                              kpi   mean\n1                     00_arrivals 230.48\n2                 01a_triage_wait  34.05\n3                 01b_triage_util   0.60\n4           02a_registration_wait 107.45\n5           02b_registration_util   0.84\n6            03a_examination_wait  23.92\n7            03b_examination_util   0.84\n8  04a_treatment_wait(non_trauma) 139.57\n9  04b_treatment_util(non_trauma)   0.87\n10      05_total_time(non-trauma) 236.96\n11         06a_stabilisation_wait   0.00\n12         06b_stabilisation_util   0.00\n13     07a_treatment_wait(trauma)  53.18\n14     07b_treatment_util(trauma)   0.65\n15          08_total_time(trauma) 197.52\n16                  09_throughput 168.54"
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Abstract",
    "section": "",
    "text": "The materials and methods in this documentation support work towards developing the S.T.A.R.S healthcare framework (Sharing Tools and Artifacts for Reproducible Simulations in healthcare). Long term S.T.A.R.S aims to support researchers share open simulation models regardless of language choice, improve the quality of sharing, and reduce the workload required to meet high standards of open science for the modelling and simulation community.\nThe code and written materials are a work in progress towards STARS version 2.0. It demonstrates the application od sharing a discrete-event simuilation model and associated research artifacts:\n\nAll artifacts in this repository are linked to study researchers via ORCIDs;\nModel code is made available under a GNU Public License version 3;\n[To do: validate and test R dependencies managed through renv]\nThe R code and simmer model are documented and explained in a quarto website served up by GitHub pages;\n[To do: the materials are deposited and made citatable using Zenodo;]\n[To do: The models are sharable with other researchers and the NHS without the need to install software.]"
  },
  {
    "objectID": "preface.html#towards-sharing-tools-artifacts-and-reproducible-simulation-a-simmer-model-example",
    "href": "preface.html#towards-sharing-tools-artifacts-and-reproducible-simulation-a-simmer-model-example",
    "title": "Abstract",
    "section": "",
    "text": "The materials and methods in this documentation support work towards developing the S.T.A.R.S healthcare framework (Sharing Tools and Artifacts for Reproducible Simulations in healthcare). Long term S.T.A.R.S aims to support researchers share open simulation models regardless of language choice, improve the quality of sharing, and reduce the workload required to meet high standards of open science for the modelling and simulation community.\nThe code and written materials are a work in progress towards STARS version 2.0. It demonstrates the application od sharing a discrete-event simuilation model and associated research artifacts:\n\nAll artifacts in this repository are linked to study researchers via ORCIDs;\nModel code is made available under a GNU Public License version 3;\n[To do: validate and test R dependencies managed through renv]\nThe R code and simmer model are documented and explained in a quarto website served up by GitHub pages;\n[To do: the materials are deposited and made citatable using Zenodo;]\n[To do: The models are sharable with other researchers and the NHS without the need to install software.]"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "💫 Towards Sharing Tools, Artifacts, and Reproducible Simulation: a simmer model example",
    "section": "",
    "text": "Reusehttps://creativecommons.org/licenses/by/4.0/CitationBibTeX citation:@online{monks,\n  author = {Monks, Thomas and Harper, Alison and Heather, Amy and\n    Mustafee, Navonil},\n  title = {💫 {Towards} {Sharing} {Tools,} {Artifacts,} and\n    {Reproducible} {Simulation:} A `Simmer` Model Example},\n  url = {https://TomMonks.github.io/treat-sim-rsimmer//},\n  doi = {10.5555/12345678_fake},\n  langid = {en},\n  abstract = {The materials and methods in this documentation support\n    work towards developing the **S.T.A.R.S healthcare framework**\n    (**S**haring **T**ools and **A**rtifacts for **R**eproducible\n    **S**imulations in healthcare). Long term S.T.A.R.S aims to support\n    researchers share open simulation models regardless of language\n    choice, improve the quality of sharing, and reduce the workload\n    required to meet high standards of open science for the modelling\n    and simulation community. The code and written materials are a\n    **work in progress** towards STARS version 2.0. It demonstrates the\n    application od sharing a discrete-event simuilation model and\n    associated research artifacts: * All artifacts in this repository\n    are linked to study researchers via ORCIDs; * Model code is made\n    available under a GNU Public License version 3; * {[}**To do**:\n    validate and test R dependencies managed through `renv`{]} * The R\n    code and simmer model are documented and explained in a quarto\n    website served up by GitHub pages; * {[}**To do**: the materials are\n    deposited and made citatable using Zenodo;{]} * {[}**To do**: The\n    models are sharable with other researchers and the NHS without the\n    need to install software.{]}}\n}\nFor attribution, please cite this work as:\nMonks, Thomas, Alison Harper, Amy Heather, and Navonil Mustafee. n.d.\n“💫 Towards Sharing Tools, Artifacts, and Reproducible Simulation:\nA `Simmer` Model Example.” Zenodo. https://doi.org/10.5555/12345678_fake."
  },
  {
    "objectID": "01_introduction/02_license.html",
    "href": "01_introduction/02_license.html",
    "title": "License",
    "section": "",
    "text": "All code is licenced under the GNU General Public License v3.0. Our decision to use GPL v3.0 is based on the dependency tree below.\n\n\n\nFigure 1: Software dependencies for treat-simr\n\n\n\n\n\nAll written content in this book is shared under CC-BY 4.0.\nYou are free to:\nShare - copy and redistribute the material in any medium or format\n\nAdapt - remix, transform, and build upon the material for any purpose, even commercially.\nYou must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use."
  },
  {
    "objectID": "01_introduction/02_license.html#code-and-model",
    "href": "01_introduction/02_license.html#code-and-model",
    "title": "License",
    "section": "",
    "text": "All code is licenced under the GNU General Public License v3.0. Our decision to use GPL v3.0 is based on the dependency tree below.\n\n\n\nFigure 1: Software dependencies for treat-simr"
  },
  {
    "objectID": "01_introduction/02_license.html#written-materials",
    "href": "01_introduction/02_license.html#written-materials",
    "title": "License",
    "section": "",
    "text": "All written content in this book is shared under CC-BY 4.0.\nYou are free to:\nShare - copy and redistribute the material in any medium or format\n\nAdapt - remix, transform, and build upon the material for any purpose, even commercially.\nYou must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use."
  },
  {
    "objectID": "02_model/02_thinning.html",
    "href": "02_model/02_thinning.html",
    "title": "Time-dependent arrivals",
    "section": "",
    "text": "The treatment simulation model has a time-dependent arrival profile for patients. To simulated these arrivals correctly in DES we need to use one of several algorithms. Here we make use of the thinning algorithm.\nThinning is a acceptance-rejection sampling method and is used to generate inter-arrival times from a NSPP.\n\nMotivation: In DES we use thinning as an approach to generate time dependent arrival of patients to a health care service.\n\n\n\nThe table below is adapted from Banks et al (2013) and breaks an arrival process down into 60 minutes intervals.\n\n\n\n\n\n\n\n\nt(min)\nMean time between arrivals (min)\nArrival Rate \\(\\lambda(t)\\) (arrivals/min)\n\n\n\n\n0\n15\n1/15\n\n\n60\n12\n1/12\n\n\n120\n7\n1/7\n\n\n180\n5\n1/5\n\n\n240\n8\n1/8\n\n\n300\n10\n1/10\n\n\n360\n15\n1/15\n\n\n420\n20\n1/20\n\n\n480\n20\n1/20\n\n\n\n\nInterpretation: In the table above the fastest arrival rate is 1/5 customers per minute or 5 minutes between patient arrivals.\n\n\n\n\nA NSPP has arrival rate \\(\\lambda(t)\\) where \\(0 \\leq t \\leq T\\)\nHere \\(i\\) is the arrival number and \\(\\mathcal{T_i}\\) is its arrival time.\n\nLet \\(\\lambda^* = \\max_{0 \\leq t \\leq T}\\lambda(t)\\) be the maximum of the arrival rate function and set \\(t = 0\\) and \\(i=1\\)\nGenerate \\(e\\) from the exponential distribution with rate \\(\\lambda^*\\) and let \\(t = t + e\\) (this is the time of the next entity will arrive)\nGenerate \\(u\\) from the \\(U(0,1)\\) distribution. If \\(u \\leq \\dfrac{\\lambda(t)}{\\lambda^*}\\) then \\(\\mathcal{T_i} =t\\) and \\(i = i + 1\\)\nGo to Step 2."
  },
  {
    "objectID": "02_model/02_thinning.html#background",
    "href": "02_model/02_thinning.html#background",
    "title": "Time-dependent arrivals",
    "section": "",
    "text": "The treatment simulation model has a time-dependent arrival profile for patients. To simulated these arrivals correctly in DES we need to use one of several algorithms. Here we make use of the thinning algorithm.\nThinning is a acceptance-rejection sampling method and is used to generate inter-arrival times from a NSPP.\n\nMotivation: In DES we use thinning as an approach to generate time dependent arrival of patients to a health care service.\n\n\n\nThe table below is adapted from Banks et al (2013) and breaks an arrival process down into 60 minutes intervals.\n\n\n\n\n\n\n\n\nt(min)\nMean time between arrivals (min)\nArrival Rate \\(\\lambda(t)\\) (arrivals/min)\n\n\n\n\n0\n15\n1/15\n\n\n60\n12\n1/12\n\n\n120\n7\n1/7\n\n\n180\n5\n1/5\n\n\n240\n8\n1/8\n\n\n300\n10\n1/10\n\n\n360\n15\n1/15\n\n\n420\n20\n1/20\n\n\n480\n20\n1/20\n\n\n\n\nInterpretation: In the table above the fastest arrival rate is 1/5 customers per minute or 5 minutes between patient arrivals.\n\n\n\n\nA NSPP has arrival rate \\(\\lambda(t)\\) where \\(0 \\leq t \\leq T\\)\nHere \\(i\\) is the arrival number and \\(\\mathcal{T_i}\\) is its arrival time.\n\nLet \\(\\lambda^* = \\max_{0 \\leq t \\leq T}\\lambda(t)\\) be the maximum of the arrival rate function and set \\(t = 0\\) and \\(i=1\\)\nGenerate \\(e\\) from the exponential distribution with rate \\(\\lambda^*\\) and let \\(t = t + e\\) (this is the time of the next entity will arrive)\nGenerate \\(u\\) from the \\(U(0,1)\\) distribution. If \\(u \\leq \\dfrac{\\lambda(t)}{\\lambda^*}\\) then \\(\\mathcal{T_i} =t\\) and \\(i = i + 1\\)\nGo to Step 2."
  },
  {
    "objectID": "02_model/02_thinning.html#imports",
    "href": "02_model/02_thinning.html#imports",
    "title": "Time-dependent arrivals",
    "section": "2. Imports",
    "text": "2. Imports\n\nlibrary(simmer)\nlibrary(tibble)\nlibrary(ggplot2)\nsuppressMessages(library(RCurl))"
  },
  {
    "objectID": "02_model/02_thinning.html#read-in-data",
    "href": "02_model/02_thinning.html#read-in-data",
    "title": "Time-dependent arrivals",
    "section": "3. Read in data",
    "text": "3. Read in data\nHere we read in the example non-stationary data and compute the arrival rate.\n\nNSPP_PATH = 'https://raw.githubusercontent.com/TomMonks/treat-sim-rsimmer/main/data/nspp_example1.csv'\n\ncsv_data &lt;- getURL(NSPP_PATH)\narrivals &lt;- read.csv(text=csv_data)\nnames(arrivals) &lt;- c(\"period\", \"mean_iat\")\n\n# create arrival rate\narrivals$arrival_rate = 1.0 / arrivals$mean_iat\n\narrivals\n\n  period mean_iat arrival_rate\n1      0       15   0.06666667\n2     60       12   0.08333333\n3    120        7   0.14285714\n4    180        5   0.20000000\n5    240        8   0.12500000\n6    300       10   0.10000000\n7    360       15   0.06666667\n8    420       20   0.05000000\n9    480       20   0.05000000\n\n\n\nggplot(data=arrivals, aes(x=period, y=mean_iat)) +\n  geom_bar(stat=\"identity\", fill=\"steelblue\") + \n  xlab(\"Time of day (mins)\") + \n  ylab(\"Mean IAT (min)\")"
  },
  {
    "objectID": "02_model/02_thinning.html#algorithm-implementation",
    "href": "02_model/02_thinning.html#algorithm-implementation",
    "title": "Time-dependent arrivals",
    "section": "4. Algorithm implementation",
    "text": "4. Algorithm implementation\n\n4.1 NSPP sampling function\n\nnspp_thinning &lt;- function(simulation_time, data, debug=FALSE){\n  \n  # calc time interval: assumes intervals are of equal length\n  interval &lt;- data$period[2] - data$period[1]\n  \n  # maximum arrival rate (smallest time between arrivals)\n  lambda_max &lt;- max(data$arrival_rate)\n\n  while(TRUE){\n    # get time bucket (row of dataframe to use)\n    t &lt;- floor(simulation_time / interval) %% nrow(data) + 1\n    lambda_t &lt;- data$arrival_rate[t]\n    \n    # set to a large number so that at least 1 sample is taken\n    u &lt;- Inf\n    rejects &lt;- -1\n    \n    # running total of time until next arrival\n    inter_arrival_time &lt;- 0.0\n    \n    # reject proportionate to lambda_t / lambda_max\n    ratio &lt;- lambda_t / lambda_max\n    while(u &gt;= ratio){\n      rejects &lt;- rejects + 1\n      # sample using max arrival rate\n      inter_arrival_time &lt;- inter_arrival_time + rexp(1, lambda_max)\n      u &lt;- runif(1, 0.0, 1.0)\n    }\n    \n    if(debug){\n      print({paste(\"Time:\", simulation_time, \n                   \" Rejections:\", rejects, \n                   \" t:\", t, \n                   \" lambda_t:\", lambda_t, \n                   \" IAT:\", inter_arrival_time)})\n    }\n      \n    return(inter_arrival_time)\n  }\n}\n\n\n\n4.2 Example usage\nThe function can be used in the same way as rexp to generate new patients. To illustrate its use we first create a simple patient pathway trajectory that prints out some event and acts as a delay.\n\npatient &lt;- trajectory(\"patient pathway\") %&gt;% \n  # just a simple delay\n  log_(function() {paste(\"Patient arrival\")}, level = 1) %&gt;% \n  timeout(function() rnorm(1, 10.0, 1.0)) %&gt;% \n  log_(function() {paste(\"Exit treatment pathway\")}, level = 1)\n\nWe then run the model with a generator that uses the nspp_thinning sampling function. Note that the function accepts the current simulation time now(env) and the dataframe containing the arrivals arrivals.\n\nImportant learning point: we need to detach run from the creation of the simulation environment. This will allow now(env) to run correctly. If we ignore this rule and include run in the creation pipe the same time will be passed to the thinning function and it will under/over sample arrivals. See https://r-simmer.org/articles/simmer-03-trajectories.html\n\n\nenv &lt;- simmer(\"TreatSim\", log_level=0) \n\nenv %&gt;% \n  add_generator(\"patient\", patient, \n                function() nspp_thinning(now(env), arrivals, debug=TRUE)) %&gt;% \n  run(until=540.0)\n\n[1] \"Time: 0  Rejections: 6  t: 1  lambda_t: 0.0666666666666667  IAT: 33.5200980320404\"\n[1] \"Time: 33.5200980320404  Rejections: 0  t: 1  lambda_t: 0.0666666666666667  IAT: 3.81393849828696\"\n[1] \"Time: 37.3340365303274  Rejections: 0  t: 1  lambda_t: 0.0666666666666667  IAT: 3.36145904147997\"\n[1] \"Time: 40.6954955718073  Rejections: 0  t: 1  lambda_t: 0.0666666666666667  IAT: 5.13485132695592\"\n[1] \"Time: 45.8303468987633  Rejections: 1  t: 1  lambda_t: 0.0666666666666667  IAT: 1.32352768772477\"\n[1] \"Time: 47.153874586488  Rejections: 1  t: 1  lambda_t: 0.0666666666666667  IAT: 1.76001061750678\"\n[1] \"Time: 48.9138852039948  Rejections: 1  t: 1  lambda_t: 0.0666666666666667  IAT: 8.61447293602623\"\n[1] \"Time: 57.528358140021  Rejections: 14  t: 1  lambda_t: 0.0666666666666667  IAT: 78.9044174392909\"\n[1] \"Time: 136.432775579312  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 3.89573549830771\"\n[1] \"Time: 140.32851107762  Rejections: 2  t: 3  lambda_t: 0.142857142857143  IAT: 9.97739376040757\"\n[1] \"Time: 150.305904838027  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 2.62906914809719\"\n[1] \"Time: 152.934973986124  Rejections: 1  t: 3  lambda_t: 0.142857142857143  IAT: 6.08679874612412\"\n[1] \"Time: 159.021772732249  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 26.7391672063817\"\n[1] \"Time: 185.76093993863  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 6.61135393639511\"\n[1] \"Time: 192.372293875025  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 2.56115276599303\"\n[1] \"Time: 194.933446641018  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 6.82137783595777\"\n[1] \"Time: 201.754824476976  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.229064174927771\"\n[1] \"Time: 201.983888651904  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 1.59620280843228\"\n[1] \"Time: 203.580091460336  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.0473874481394887\"\n[1] \"Time: 203.627478908476  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 14.9578277013245\"\n[1] \"Time: 218.5853066098  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 3.22828953154385\"\n[1] \"Time: 221.813596141344  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 1.7590237618424\"\n[1] \"Time: 223.572619903186  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.17247998278517\"\n[1] \"Time: 223.745099885972  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 3.08621887350455\"\n[1] \"Time: 226.831318759476  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.65752177266404\"\n[1] \"Time: 227.48884053214  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 1.18241797434166\"\n[1] \"Time: 228.671258506482  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 5.07960279451168\"\n[1] \"Time: 233.750861300994  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 17.4399162872808\"\n[1] \"Time: 251.190777588274  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 0.947026163339615\"\n[1] \"Time: 252.137803751614  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 2.46803309535608\"\n[1] \"Time: 254.60583684697  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 3.82389974246337\"\n[1] \"Time: 258.429736589433  Rejections: 2  t: 5  lambda_t: 0.125  IAT: 21.7076573021452\"\n[1] \"Time: 280.137393891579  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 10.8858477597343\"\n[1] \"Time: 291.023241651313  Rejections: 1  t: 5  lambda_t: 0.125  IAT: 16.1418948360699\"\n[1] \"Time: 307.165136487383  Rejections: 0  t: 6  lambda_t: 0.1  IAT: 2.86286774324253\"\n[1] \"Time: 310.028004230625  Rejections: 1  t: 6  lambda_t: 0.1  IAT: 8.15702171685576\"\n[1] \"Time: 318.185025947481  Rejections: 1  t: 6  lambda_t: 0.1  IAT: 15.8306994003462\"\n[1] \"Time: 334.015725347827  Rejections: 1  t: 6  lambda_t: 0.1  IAT: 21.6951490392651\"\n[1] \"Time: 355.710874387092  Rejections: 2  t: 6  lambda_t: 0.1  IAT: 10.6123247695669\"\n[1] \"Time: 366.323199156659  Rejections: 4  t: 7  lambda_t: 0.0666666666666667  IAT: 25.2464647510238\"\n[1] \"Time: 391.569663907683  Rejections: 4  t: 7  lambda_t: 0.0666666666666667  IAT: 23.8610684209245\"\n[1] \"Time: 415.430732328607  Rejections: 2  t: 7  lambda_t: 0.0666666666666667  IAT: 6.35584883857518\"\n[1] \"Time: 421.786581167183  Rejections: 1  t: 8  lambda_t: 0.05  IAT: 8.98481857709071\"\n[1] \"Time: 430.771399744273  Rejections: 0  t: 8  lambda_t: 0.05  IAT: 13.134219450246\"\n[1] \"Time: 443.905619194519  Rejections: 0  t: 8  lambda_t: 0.05  IAT: 0.0909088331505746\"\n[1] \"Time: 443.99652802767  Rejections: 1  t: 8  lambda_t: 0.05  IAT: 6.24467818743965\"\n[1] \"Time: 450.241206215109  Rejections: 1  t: 8  lambda_t: 0.05  IAT: 14.8813823113198\"\n[1] \"Time: 465.122588526429  Rejections: 6  t: 8  lambda_t: 0.05  IAT: 38.8672440589675\"\n[1] \"Time: 503.989832585397  Rejections: 4  t: 9  lambda_t: 0.05  IAT: 12.9348669780072\"\n[1] \"Time: 516.924699563404  Rejections: 2  t: 9  lambda_t: 0.05  IAT: 19.7696259574812\"\n[1] \"Time: 536.694325520885  Rejections: 9  t: 9  lambda_t: 0.05  IAT: 67.2666817708089\"\n\n\nsimmer environment: TreatSim | now: 540 | next: 547.565856749039\n{ Monitor: in memory }\n{ Source: patient | monitored: 1 | n_generated: 51 }"
  },
  {
    "objectID": "02_model/02_thinning.html#validation",
    "href": "02_model/02_thinning.html#validation",
    "title": "Time-dependent arrivals",
    "section": "5. Validation",
    "text": "5. Validation\n\nThe total number of arrivals in 540 minutes\n\nHere we will repeat the same 10,000 times and then explore the distribution of the number of arrivals. If all has gone to plan this should be a Poisson distribution with mean ~53.\n\n# expected arrivals from data.\nround(sum(arrivals$arrival_rate * 60), 2)\n\n[1] 53.07\n\n\nWe can use the simmer function get_n_generated to return the number of patients generated.\n\narrivals_by_replication &lt;- function(envs){\n  results &lt;- vector()\n  for(env in envs){\n    results &lt;- c(results, get_n_generated(env, \"patient\"))\n  }\n  return(data.frame(results))\n}\n\n\nsingle_run &lt;- function(env, rep_number, run_length, debug_arrivals=FALSE){\n  env %&gt;% \n    add_generator(\"patient\", patient, \n                  function() nspp_thinning(now(env), arrivals, debug=debug_arrivals)) %&gt;% \n    run(until=540.0)\n  return(env)\n}\n\n\nRUN_LENGTH &lt;- 540.0\nN_REPS &lt;- 500\nSEED &lt;- 42\n\nset.seed(SEED)\n\npatient &lt;- trajectory(\"patient pathway\") %&gt;% \n  # just a simple delay\n  log_(function() {paste(\"Exit treatment pathway\")}, level = 1)\n\n# note unlike in simmer documentation we use a traditional for loop\n# instead of lapply. This allows us to separeate env creation\n# from run and preserve the environment interaction between NSPP \n# and current sim time.\nenvs = vector()\nfor(rep in 1:N_REPS){\n  env &lt;- simmer(\"TreatSim\", log_level=0) \n  single_run(env, i, RUN_LENGTH)\n  envs &lt;- c(envs, env)\n}\n\n# # get the number of arrivals generated\nresults &lt;- arrivals_by_replication(envs)\n\n# show mean number of arrivals. Should be close to 53\nmean(results$results)\n\n[1] 53.552\n\n\n\nggplot(results, aes(x=results)) + \n  geom_histogram(binwidth=1, fill=\"steelblue\") + \n  xlab(\"Patient arrivals in 540 minutes\") + \n  ylab(\"Replications\")"
  },
  {
    "objectID": "02_model/02_thinning.html#running-code",
    "href": "02_model/02_thinning.html#running-code",
    "title": "Time-dependent arrivals",
    "section": "Running Code",
    "text": "Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  }
]