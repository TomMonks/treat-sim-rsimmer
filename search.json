[
  {
    "objectID": "02_model/02_thinning.html",
    "href": "02_model/02_thinning.html",
    "title": "Simulating time-dependent arrivals using thinning",
    "section": "",
    "text": "Thinning is a acceptance-rejection sampling method and is used to generate inter-arrival times from a NSPP.\n\nMotivation: In DES we use thinning as an approach to generate time dependent arrival of patients to a health care service.\n\n\n\nThe table below is adapted from Banks et al (2013) and breaks an arrival process down into 60 minutes intervals.\n\n\n\n\n\n\n\n\nt(min)\nMean time between arrivals (min)\nArrival Rate \\(\\lambda(t)\\) (arrivals/min)\n\n\n\n\n0\n15\n1/15\n\n\n60\n12\n1/12\n\n\n120\n7\n1/7\n\n\n180\n5\n1/5\n\n\n240\n8\n1/8\n\n\n300\n10\n1/10\n\n\n360\n15\n1/15\n\n\n420\n20\n1/20\n\n\n480\n20\n1/20\n\n\n\n\nInterpretation: In the table above the fastest arrival rate is 1/5 customers per minute or 5 minutes between patient arrivals.\n\n\n\n\nA NSPP has arrival rate \\(\\lambda(t)\\) where \\(0 \\leq t \\leq T\\)\nHere \\(i\\) is the arrival number and \\(\\mathcal{T_i}\\) is its arrival time.\n\nLet \\(\\lambda^* = \\max_{0 \\leq t \\leq T}\\lambda(t)\\) be the maximum of the arrival rate function and set \\(t = 0\\) and \\(i=1\\)\nGenerate \\(e\\) from the exponential distribution with rate \\(\\lambda^*\\) and let \\(t = t + e\\) (this is the time of the next entity will arrive)\nGenerate \\(u\\) from the \\(U(0,1)\\) distribution. If \\(u \\leq \\dfrac{\\lambda(t)}{\\lambda^*}\\) then \\(\\mathcal{T_i} =t\\) and \\(i = i + 1\\)\nGo to Step 2."
  },
  {
    "objectID": "02_model/02_thinning.html#background",
    "href": "02_model/02_thinning.html#background",
    "title": "Simulating time-dependent arrivals using thinning",
    "section": "",
    "text": "Thinning is a acceptance-rejection sampling method and is used to generate inter-arrival times from a NSPP.\n\nMotivation: In DES we use thinning as an approach to generate time dependent arrival of patients to a health care service.\n\n\n\nThe table below is adapted from Banks et al (2013) and breaks an arrival process down into 60 minutes intervals.\n\n\n\n\n\n\n\n\nt(min)\nMean time between arrivals (min)\nArrival Rate \\(\\lambda(t)\\) (arrivals/min)\n\n\n\n\n0\n15\n1/15\n\n\n60\n12\n1/12\n\n\n120\n7\n1/7\n\n\n180\n5\n1/5\n\n\n240\n8\n1/8\n\n\n300\n10\n1/10\n\n\n360\n15\n1/15\n\n\n420\n20\n1/20\n\n\n480\n20\n1/20\n\n\n\n\nInterpretation: In the table above the fastest arrival rate is 1/5 customers per minute or 5 minutes between patient arrivals.\n\n\n\n\nA NSPP has arrival rate \\(\\lambda(t)\\) where \\(0 \\leq t \\leq T\\)\nHere \\(i\\) is the arrival number and \\(\\mathcal{T_i}\\) is its arrival time.\n\nLet \\(\\lambda^* = \\max_{0 \\leq t \\leq T}\\lambda(t)\\) be the maximum of the arrival rate function and set \\(t = 0\\) and \\(i=1\\)\nGenerate \\(e\\) from the exponential distribution with rate \\(\\lambda^*\\) and let \\(t = t + e\\) (this is the time of the next entity will arrive)\nGenerate \\(u\\) from the \\(U(0,1)\\) distribution. If \\(u \\leq \\dfrac{\\lambda(t)}{\\lambda^*}\\) then \\(\\mathcal{T_i} =t\\) and \\(i = i + 1\\)\nGo to Step 2."
  },
  {
    "objectID": "02_model/02_thinning.html#imports",
    "href": "02_model/02_thinning.html#imports",
    "title": "Simulating time-dependent arrivals using thinning",
    "section": "2. Imports",
    "text": "2. Imports\n\nlibrary(simmer)\nlibrary(tibble)\nlibrary(ggplot2)\nsuppressMessages(library(RCurl))"
  },
  {
    "objectID": "02_model/02_thinning.html#read-in-data",
    "href": "02_model/02_thinning.html#read-in-data",
    "title": "Simulating time-dependent arrivals using thinning",
    "section": "3. Read in data",
    "text": "3. Read in data\nHere we read in the example non-stationary data and compute the arrival rate.\n\nNSPP_PATH = 'https://raw.githubusercontent.com/TomMonks/treat-sim-rsimmer/main/data/nspp_example1.csv'\n\ncsv_data &lt;- getURL(NSPP_PATH)\narrivals &lt;- read.csv(text=csv_data)\nnames(arrivals) &lt;- c(\"period\", \"mean_iat\")\n\n# create arrival rate\narrivals$arrival_rate = 1.0 / arrivals$mean_iat\n\narrivals\n\n  period mean_iat arrival_rate\n1      0       15   0.06666667\n2     60       12   0.08333333\n3    120        7   0.14285714\n4    180        5   0.20000000\n5    240        8   0.12500000\n6    300       10   0.10000000\n7    360       15   0.06666667\n8    420       20   0.05000000\n9    480       20   0.05000000\n\n\n\nggplot(data=arrivals, aes(x=period, y=mean_iat)) +\n  geom_bar(stat=\"identity\", fill=\"steelblue\") + \n  xlab(\"Time of day (mins)\") + \n  ylab(\"Mean IAT (min)\")"
  },
  {
    "objectID": "02_model/02_thinning.html#algorithm-implementation",
    "href": "02_model/02_thinning.html#algorithm-implementation",
    "title": "Simulating time-dependent arrivals using thinning",
    "section": "4. Algorithm implementation",
    "text": "4. Algorithm implementation\n\n4.1 NSPP sampling function\n\nnspp_thinning &lt;- function(simulation_time, data, debug=FALSE){\n  \n  # calc time interval: assumes intervals are of equal length\n  interval &lt;- data$period[2] - data$period[1]\n  \n  # maximum arrival rate (smallest time between arrivals)\n  lambda_max &lt;- max(data$arrival_rate)\n\n  while(TRUE){\n    # get time bucket (row of dataframe to use)\n    t &lt;- floor(simulation_time / interval) %% nrow(data) + 1\n    lambda_t &lt;- data$arrival_rate[t]\n    \n    # set to a large number so that at least 1 sample is taken\n    u &lt;- Inf\n    rejects &lt;- -1\n    \n    # running total of time until next arrival\n    inter_arrival_time &lt;- 0.0\n    \n    # reject proportionate to lambda_t / lambda_max\n    ratio &lt;- lambda_t / lambda_max\n    while(u &gt;= ratio){\n      rejects &lt;- rejects + 1\n      # sample using max arrival rate\n      inter_arrival_time &lt;- inter_arrival_time + rexp(1, lambda_max)\n      u &lt;- runif(1, 0.0, 1.0)\n    }\n    \n    if(debug){\n      print({paste(\"Time:\", simulation_time, \n                   \" Rejections:\", rejects, \n                   \" t:\", t, \n                   \" lambda_t:\", lambda_t, \n                   \" IAT:\", inter_arrival_time)})\n    }\n      \n    return(inter_arrival_time)\n  }\n}\n\n\n\n4.2 Example usage\nThe function can be used in the same way as rexp to generate new patients. To illustrate its use we first create a simple patient pathway trajectory that prints out some event and acts as a delay.\n\npatient &lt;- trajectory(\"patient pathway\") %&gt;% \n  # just a simple delay\n  log_(function() {paste(\"Patient arrival\")}, level = 1) %&gt;% \n  timeout(function() rnorm(1, 10.0, 1.0)) %&gt;% \n  log_(function() {paste(\"Exit treatment pathway\")}, level = 1)\n\nWe then run the model with a generator that uses the nspp_thinning sampling function. Note that the function accepts the current simulation time now(env) and the dataframe containing the arrivals arrivals.\n\nImportant learning point: we need to detach run from the creation of the simulation environment. This will allow now(env) to run correctly. If we ignore this rule and include run in the creation pipe the same time will be passed to the thinning function and it will under/over sample arrivals. See https://r-simmer.org/articles/simmer-03-trajectories.html\n\n\nenv &lt;- simmer(\"TreatSim\", log_level=0) \n\nenv %&gt;% \n  add_generator(\"patient\", patient, \n                function() nspp_thinning(now(env), arrivals, debug=TRUE)) %&gt;% \n  run(until=540.0)\n\n[1] \"Time: 0  Rejections: 0  t: 1  lambda_t: 0.0666666666666667  IAT: 1.69880660716444\"\n[1] \"Time: 1.69880660716444  Rejections: 1  t: 1  lambda_t: 0.0666666666666667  IAT: 13.3461181766571\"\n[1] \"Time: 15.0449247838216  Rejections: 1  t: 1  lambda_t: 0.0666666666666667  IAT: 11.8028253892655\"\n[1] \"Time: 26.847750173087  Rejections: 0  t: 1  lambda_t: 0.0666666666666667  IAT: 6.8812935145334\"\n[1] \"Time: 33.7290436876204  Rejections: 1  t: 1  lambda_t: 0.0666666666666667  IAT: 8.26983435055977\"\n[1] \"Time: 41.9988780381802  Rejections: 1  t: 1  lambda_t: 0.0666666666666667  IAT: 11.6883080849224\"\n[1] \"Time: 53.6871861231026  Rejections: 0  t: 1  lambda_t: 0.0666666666666667  IAT: 12.7767014217781\"\n[1] \"Time: 66.4638875448807  Rejections: 0  t: 2  lambda_t: 0.0833333333333333  IAT: 4.85288361532098\"\n[1] \"Time: 71.3167711602017  Rejections: 0  t: 2  lambda_t: 0.0833333333333333  IAT: 7.63695049057615\"\n[1] \"Time: 78.9537216507779  Rejections: 0  t: 2  lambda_t: 0.0833333333333333  IAT: 0.553962071509145\"\n[1] \"Time: 79.507683722287  Rejections: 0  t: 2  lambda_t: 0.0833333333333333  IAT: 5.63551776555783\"\n[1] \"Time: 85.1432014878448  Rejections: 0  t: 2  lambda_t: 0.0833333333333333  IAT: 1.4989013900049\"\n[1] \"Time: 86.6421028778497  Rejections: 1  t: 2  lambda_t: 0.0833333333333333  IAT: 6.2328787029483\"\n[1] \"Time: 92.874981580798  Rejections: 1  t: 2  lambda_t: 0.0833333333333333  IAT: 8.98813287934502\"\n[1] \"Time: 101.863114460143  Rejections: 4  t: 2  lambda_t: 0.0833333333333333  IAT: 35.1788846635036\"\n[1] \"Time: 137.041999123647  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 0.459319090500339\"\n[1] \"Time: 137.501318214147  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 5.07618321770192\"\n[1] \"Time: 142.577501431849  Rejections: 1  t: 3  lambda_t: 0.142857142857143  IAT: 25.6907998055421\"\n[1] \"Time: 168.268301237391  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 14.7935524843217\"\n[1] \"Time: 183.061853721713  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 3.08310402557254\"\n[1] \"Time: 186.144957747285  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 2.46693890541792\"\n[1] \"Time: 188.611896652703  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 5.28786014744496\"\n[1] \"Time: 193.899756800148  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 4.13696450745638\"\n[1] \"Time: 198.036721307605  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 2.39246364450082\"\n[1] \"Time: 200.429184952105  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 3.31089964136481\"\n[1] \"Time: 203.74008459347  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 1.2721657546511\"\n[1] \"Time: 205.012250348121  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 1.49645049590617\"\n[1] \"Time: 206.508700844027  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 2.58059796877205\"\n[1] \"Time: 209.0892988128  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 2.48613589908928\"\n[1] \"Time: 211.575434711889  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.109507439192384\"\n[1] \"Time: 211.684942151081  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 8.90950596849334\"\n[1] \"Time: 220.594448119575  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 2.21048654057086\"\n[1] \"Time: 222.804934660145  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.673685704823583\"\n[1] \"Time: 223.478620364969  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 3.75282645620907\"\n[1] \"Time: 227.231446821178  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.48796003792337\"\n[1] \"Time: 227.719406859101  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 12.3837447958182\"\n[1] \"Time: 240.10315165492  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 6.947539217573\"\n[1] \"Time: 247.050690872493  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 0.362639001104981\"\n[1] \"Time: 247.413329873598  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 2.84222842426971\"\n[1] \"Time: 250.255558297867  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 13.4969411504673\"\n[1] \"Time: 263.752499448335  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 6.31330950164652\"\n[1] \"Time: 270.065808949981  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 6.6078837958858\"\n[1] \"Time: 276.673692745867  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 14.5141022643986\"\n[1] \"Time: 291.187795010265  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 2.39427604479715\"\n[1] \"Time: 293.582071055063  Rejections: 1  t: 5  lambda_t: 0.125  IAT: 7.88301394819424\"\n[1] \"Time: 301.465085003257  Rejections: 0  t: 6  lambda_t: 0.1  IAT: 8.94239792060765\"\n[1] \"Time: 310.407482923865  Rejections: 2  t: 6  lambda_t: 0.1  IAT: 23.8724826410286\"\n[1] \"Time: 334.279965564893  Rejections: 1  t: 6  lambda_t: 0.1  IAT: 4.46163992164657\"\n[1] \"Time: 338.74160548654  Rejections: 0  t: 6  lambda_t: 0.1  IAT: 0.447697056485606\"\n[1] \"Time: 339.189302543025  Rejections: 0  t: 6  lambda_t: 0.1  IAT: 3.53049943668252\"\n[1] \"Time: 342.719801979708  Rejections: 0  t: 6  lambda_t: 0.1  IAT: 10.666350526105\"\n[1] \"Time: 353.386152505813  Rejections: 0  t: 6  lambda_t: 0.1  IAT: 5.46156909830504\"\n[1] \"Time: 358.847721604118  Rejections: 0  t: 6  lambda_t: 0.1  IAT: 0.363520032260567\"\n[1] \"Time: 359.211241636379  Rejections: 0  t: 6  lambda_t: 0.1  IAT: 3.17625657888129\"\n[1] \"Time: 362.38749821526  Rejections: 1  t: 7  lambda_t: 0.0666666666666667  IAT: 1.36976879555732\"\n[1] \"Time: 363.757267010817  Rejections: 2  t: 7  lambda_t: 0.0666666666666667  IAT: 9.50022503246969\"\n[1] \"Time: 373.257492043287  Rejections: 0  t: 7  lambda_t: 0.0666666666666667  IAT: 4.75811892168081\"\n[1] \"Time: 378.015610964968  Rejections: 7  t: 7  lambda_t: 0.0666666666666667  IAT: 30.6297075292935\"\n[1] \"Time: 408.645318494261  Rejections: 4  t: 7  lambda_t: 0.0666666666666667  IAT: 52.5862767374314\"\n[1] \"Time: 461.231595231693  Rejections: 7  t: 8  lambda_t: 0.05  IAT: 41.2750424484635\"\n[1] \"Time: 502.506637680156  Rejections: 1  t: 9  lambda_t: 0.05  IAT: 6.87300560575978\"\n[1] \"Time: 509.379643285916  Rejections: 0  t: 9  lambda_t: 0.05  IAT: 3.96026968003667\"\n[1] \"Time: 513.339912965952  Rejections: 0  t: 9  lambda_t: 0.05  IAT: 3.58783915777821\"\n[1] \"Time: 516.927752123731  Rejections: 2  t: 9  lambda_t: 0.05  IAT: 4.87662526113194\"\n[1] \"Time: 521.804377384863  Rejections: 2  t: 9  lambda_t: 0.05  IAT: 29.8048130871688\"\n\n\nsimmer environment: TreatSim | now: 540 | next: 551.609190472031\n{ Monitor: in memory }\n{ Source: patient | monitored: 1 | n_generated: 65 }"
  },
  {
    "objectID": "02_model/02_thinning.html#validation",
    "href": "02_model/02_thinning.html#validation",
    "title": "Simulating time-dependent arrivals using thinning",
    "section": "5. Validation",
    "text": "5. Validation\n\nThe total number of arrivals in 540 minutes\n\nHere we will repeat the same 10,000 times and then explore the distribution of the number of arrivals. If all has gone to plan this should be a Poisson distribution with mean ~53.\n\n# expected arrivals from data.\nround(sum(arrivals$arrival_rate * 60), 2)\n\n[1] 53.07\n\n\nWe can use the simmer function get_n_generated to return the number of patients generated.\n\narrivals_by_replication &lt;- function(envs){\n  results &lt;- vector()\n  for(env in envs){\n    results &lt;- c(results, get_n_generated(env, \"patient\"))\n  }\n  return(data.frame(results))\n}\n\n\nsingle_run &lt;- function(env, rep_number, run_length, debug_arrivals=FALSE){\n  env %&gt;% \n    add_generator(\"patient\", patient, \n                  function() nspp_thinning(now(env), arrivals, debug=debug_arrivals)) %&gt;% \n    run(until=540.0)\n  return(env)\n}\n\n\nRUN_LENGTH &lt;- 540.0\nN_REPS &lt;- 500\nSEED &lt;- 42\n\nset.seed(SEED)\n\npatient &lt;- trajectory(\"patient pathway\") %&gt;% \n  # just a simple delay\n  log_(function() {paste(\"Exit treatment pathway\")}, level = 1)\n\n# note unlike in simmer documentation we use a traditional for loop\n# instead of lapply. This allows us to separeate env creation\n# from run and preserve the environment interaction between NSPP \n# and current sim time.\nenvs = vector()\nfor(rep in 1:N_REPS){\n  env &lt;- simmer(\"TreatSim\", log_level=0) \n  single_run(env, i, RUN_LENGTH)\n  envs &lt;- c(envs, env)\n}\n\n# # get the number of arrivals generated\nresults &lt;- arrivals_by_replication(envs)\n\n# show mean number of arrivals. Should be close to 53\nmean(results$results)\n\n[1] 53.552\n\n\n\nggplot(results, aes(x=results)) + \n  geom_histogram(binwidth=1, fill=\"steelblue\") + \n  xlab(\"Patient arrivals in 540 minutes\") + \n  ylab(\"Replications\")"
  },
  {
    "objectID": "02_model/02_thinning.html#running-code",
    "href": "02_model/02_thinning.html#running-code",
    "title": "Simulating time-dependent arrivals using thinning",
    "section": "Running Code",
    "text": "Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Abstract",
    "section": "",
    "text": "The materials and methods in this documentation support work towards developing the S.T.A.R.S healthcare framework (Sharing Tools and Artifacts for Reproducible Simulations in healthcare). Long term S.T.A.R.S aims to support researchers share open simulation models regardless of language choice, improve the quality of sharing, and reduce the workload required to meet high standards of open science for the modelling and simulation community.\nThe code and written materials here demonstrate the application of S.T.A.R.S’ version 1 to sharing a ciw discrete-event simuilation model and associated research artifacts.\n\nAll artifacts in this repository are linked to study researchers via ORCIDs;\nModel code is made available under a GNU Public License version 3;\nPython dependencies are managed through conda;`\nThe code builds a Shiny for Python web application that can be used to run the model (web app);\nThe python code itself can be viewed and executed in Jupyter notebooks via Binder;\nThe model is documented and explained in a quarto website served up by GitHub pages;\nThe materials are deposited and made citatable using Zenodo;\nThe models are sharable with other researchers and the NHS without the need to install software."
  },
  {
    "objectID": "preface.html#towards-sharing-tools-artifacts-and-reproducible-simulation-a-simmer-model-examplar",
    "href": "preface.html#towards-sharing-tools-artifacts-and-reproducible-simulation-a-simmer-model-examplar",
    "title": "Abstract",
    "section": "",
    "text": "The materials and methods in this documentation support work towards developing the S.T.A.R.S healthcare framework (Sharing Tools and Artifacts for Reproducible Simulations in healthcare). Long term S.T.A.R.S aims to support researchers share open simulation models regardless of language choice, improve the quality of sharing, and reduce the workload required to meet high standards of open science for the modelling and simulation community.\nThe code and written materials here demonstrate the application of S.T.A.R.S’ version 1 to sharing a ciw discrete-event simuilation model and associated research artifacts.\n\nAll artifacts in this repository are linked to study researchers via ORCIDs;\nModel code is made available under a GNU Public License version 3;\nPython dependencies are managed through conda;`\nThe code builds a Shiny for Python web application that can be used to run the model (web app);\nThe python code itself can be viewed and executed in Jupyter notebooks via Binder;\nThe model is documented and explained in a quarto website served up by GitHub pages;\nThe materials are deposited and made citatable using Zenodo;\nThe models are sharable with other researchers and the NHS without the need to install software."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Towards Sharing Tools, Artifacts, and Reproducible Simulation: a ciw model examplar",
    "section": "",
    "text": "Reusehttps://creativecommons.org/licenses/by/4.0/CitationBibTeX citation:@online{monks,\n  author = {Monks, Thomas and Harper, Alison},\n  title = {Towards {Sharing} {Tools,} {Artifacts,} and {Reproducible}\n    {Simulation:} A `Ciw` Model Examplar},\n  url = {https://TomMonks.github.io/treat-sim-rsimmer//},\n  doi = {10.5555/12345678_fake},\n  langid = {en},\n  abstract = {The materials and methods in this documentation support\n    work towards developing the **S.T.A.R.S healthcare framework**\n    (**S**haring **T**ools and **A**rtifacts for **R**eproducible\n    **S**imulations in healthcare). Long term S.T.A.R.S aims to support\n    researchers share open simulation models regardless of language\n    choice, improve the quality of sharing, and reduce the workload\n    required to meet high standards of open science for the modelling\n    and simulation community. The code and written materials here\n    demonstrate the application of S.T.A.R.S’ version 1 to sharing a\n    `ciw` discrete-event simuilation model and associated research\n    artifacts: * All artifacts in this repository are linked to study\n    researchers via ORCIDs; * Model code is made available under a GNU\n    Public License version 3; * Python dependencies are managed through\n    `conda`;` * The code builds a Shiny for Python web application that\n    can be used to run the model (web app); * The python code itself can\n    be viewed and executed in Jupyter notebooks via\n    {[}Binder{]}(https://mybinder.org); * The model is documented and\n    explained in a quarto website served up by GitHub pages; * The\n    materials are deposited and made citatable using Zenodo; * The\n    models are sharable with other researchers and the NHS without the\n    need to install software.}\n}\nFor attribution, please cite this work as:\nMonks, Thomas, and Alison Harper. n.d. “Towards Sharing Tools,\nArtifacts, and Reproducible Simulation: A `Ciw` Model Examplar.”\nZenodo. https://doi.org/10.5555/12345678_fake."
  },
  {
    "objectID": "02_model/01_model.html",
    "href": "02_model/01_model.html",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "",
    "text": "Note: we are calculating KPIs using our own code here, but you can also use simmer.plot. Help with install of simmer.plot (igraph installation is the actual issue) on Linux based systems: https://r.igraph.org/articles/installation-troubleshooting#cannot-compile-igraph-from-sources-on-linux\n\nIf you make use of conda environments (via Anaconda/mini-conda/mini-forge/mamba), remember to conda deactivate before installation.\n\n\n\nlibrary(simmer)\nlibrary(simmer.bricks)\nsuppressMessages(library(simmer.plot))\nlibrary(tibble)\nlibrary(ggplot2)\nsuppressMessages(library(RCurl))\nsuppressMessages(library(Rlab))\nsuppressMessages(library(dplyr))\nsuppressMessages(library(tidyr))\n\noptions(dplyr.summarise.inform = FALSE)"
  },
  {
    "objectID": "02_model/01_model.html#imports",
    "href": "02_model/01_model.html#imports",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "",
    "text": "Note: we are calculating KPIs using our own code here, but you can also use simmer.plot. Help with install of simmer.plot (igraph installation is the actual issue) on Linux based systems: https://r.igraph.org/articles/installation-troubleshooting#cannot-compile-igraph-from-sources-on-linux\n\nIf you make use of conda environments (via Anaconda/mini-conda/mini-forge/mamba), remember to conda deactivate before installation.\n\n\n\nlibrary(simmer)\nlibrary(simmer.bricks)\nsuppressMessages(library(simmer.plot))\nlibrary(tibble)\nlibrary(ggplot2)\nsuppressMessages(library(RCurl))\nsuppressMessages(library(Rlab))\nsuppressMessages(library(dplyr))\nsuppressMessages(library(tidyr))\n\noptions(dplyr.summarise.inform = FALSE)"
  },
  {
    "objectID": "02_model/01_model.html#default-values-and-constants",
    "href": "02_model/01_model.html#default-values-and-constants",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "2. Default values and constants",
    "text": "2. Default values and constants\n\n2.1 Distribution parameters\n\n#' Mean and Variance of the underlying Normal Distribution\n#' \n#' @description\n#' `normal_moments_from_lognormal` calculates the mu and sigma\n#' of the normal distribution underlying a lognormal\n#' mean and standard \n#'\n#' @details\n#' `rlnorm` from `stats` is designed to sample from the lognormal distribution. \n#' The parameters is expects are moments of the underlying normal distribution\n#' Using sample mean and standard deviation this function calculates \n#' the mu and sigma of the normal distribution. source: https://blogs.sas.com/content/iml/2014/06/04/simulate-lognormal-data-with-specified-mean-and-variance.html\n#' \n#' @param mean A number. Sample mean.\n#' @param stdev A number. Sample standard deviation\n#' @returns A list \nnormal_moments_from_lognormal &lt;- function(mean, std){\n  phi &lt;- sqrt(std^2 + mean^2)\n  mu &lt;- log(mean**2/phi)\n  sigma &lt;- sqrt(log(phi^2/mean^2))\n  return(list(\"mu\" = mu, \"sigma\" = sigma))\n}\n\n\n# sign-in/triage parameters\nDEFAULT_TRIAGE_MEAN &lt;- 3.0\n\n# registration parameters (lognormal distribution)\nDEFAULT_REG_PARAMS &lt;- normal_moments_from_lognormal(5.0, sqrt(2.0))\n\n# examination parameters\nDEFAULT_EXAM_PARAMS = list(mean=16.0, var=3.0)\n\n# trauma/stabilisation\nDEFAULT_TRAUMA_MEAN &lt;- 90.0\n\n# Trauma treatment (lognormal distribution)\nDEFAULT_TRAUMA_TREATMENT_PARAMS &lt;- normal_moments_from_lognormal(30.0, sqrt(4.0))\n\n# Non trauma treatment (lognormal distribution)\nDEFAULT_NON_TRAUMA_TREATMENT_PARAMS &lt;- normal_moments_from_lognormal(13.3, sqrt(2.0))\n\n# prob patient requires treatment given trauma\nDEFAULT_NON_TRAUMA_TREAT_P &lt;- 0.60\n\n# proportion of patients triaged as trauma\nDEFAULT_PROB_TRAUMA &lt;- 0.12\n\n\n\n2.2 Time dependent arrival rate data\nThe data for arrival rates varies between clinic opening at 6am and closure at 12am.\n\n# data are held in the Github repo and loaded from there.\nNSPP_PATH = 'https://raw.githubusercontent.com/TomMonks/open-science-for-sim/main/src/notebooks/01_foss_sim/data/ed_arrivals.csv'\n\ncsv_data &lt;- getURL(NSPP_PATH)\ndf &lt;- read.csv(text=csv_data)\n\n# lock in order of time of day for bar chart display\ndf$period &lt;- factor(df$period, levels = df$period)\n\nggplot(data=df, aes(x=period, y=arrival_rate)) +\n  geom_bar(stat=\"identity\", fill=\"steelblue\") + \n  theme(axis.text.x = element_text(angle = 90, \n                                   vjust = 0.5, \n                                   hjust=1)) +\n  xlab(\"Hour of day\") + \n  ylab(\"Mean arrivals (patients/hr)\")\n\n\n\n\n\n\n2.3 Resource Counts\nInteger count variables representing the number of resources at each activity in the process\n\nDEFAULT_N_TRIAGE &lt;- 1\nDEFAULT_N_REG &lt;- 1\nDEFAULT_N_EXAM &lt;- 3\n\n# stabilisation rooms\nDEFAULT_N_TRAUMA &lt;- 10000\n\n# Non-trauma cubicles\nDEFAULT_NON_TRAUMA_CUBICLES &lt;- 1\n\n# trauma pathway cubicles\nDEFAULT_TRAUMA_CUBICLES &lt;- 1\n\n\n\n2.4 Simulation model run settings\n\n# Random seed - this will be investigated for CRN\nSEED &lt;- 42\n\n# default results collection period\nDEFAULT_RESULTS_COLLECTION_PERIOD &lt;- 60 * 19\n\n# number of replications.\nDEFAULT_N_REPS &lt;- 5\n\n# Show the a trace of simulated events\n# 1 = show, 0 = do not show.\nLOG_LEVEL &lt;- 1"
  },
  {
    "objectID": "02_model/01_model.html#functions",
    "href": "02_model/01_model.html#functions",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "3. Functions",
    "text": "3. Functions\nLoad and format data\n\nload_arrival_data &lt;- function(path=NSPP_PATH){\n  csv_data &lt;- getURL(NSPP_PATH)\n  df &lt;- read.csv(text=csv_data)\n  \n  # arrivals per minute...\n  df$arrival_rate2 &lt;- df$arrival_rate/60.0\n  \n  # create 60 minute increments for period\n  df$period = seq(0, (nrow(df)-1)*60, by=60)\n  return(df)\n}\n\n\n#' Sample a patient type\n#' \n#' @description\n#' `sample_arrival_type` samples if a patient type is trauma or non-trauma\n#' with a given probability.\n#'\n#' @details\n#' The function uses the Bernouli distribution (Rlab) to sample\n#' if a patient is Trauma or Non-Trauma.  The return values are \n#' 1 = Trauma, 2 = Non-trauma.\n#' @param p A number: the probability a patient has trauma on arrival\nsample_arrival_type &lt;- function(p, n=1){\n  ifelse(rbern(n, prob = DEFAULT_PROB_TRAUMA) == 1, 1, 2)\n}\n\n\n#' Sample a if a non-trauma patient requires treatment\n#' \n#' @description\n#' `sample_nt_trauma_treatment` samples if a non-trauma patient\n#' requires cubicle treatment\n#'\n#' @details\n#' The function uses the Bernouli distribution (Rlab) to sample\n#' if a patient is requires treatment or not.  The return values are \n#' 1 = Treatment, 0 = No treatment\n#' @param p A number: The probability the patient requires treatment\nsample_nt_trauma_treatment &lt;- function(p){\n  ifelse(rbern(1, prob = p) == 1, 1, 0)\n}\n\nSampling from a non-stationary poisson process using thinning\n\nnspp_thinning &lt;- function(simulation_time, data, debug=FALSE){\n  \n  # calc time interval: assumes intervals are of equal length\n  interval &lt;- data$period[2] - data$period[1]\n  \n  # maximum arrival rate (smallest time between arrivals)\n  lambda_max &lt;- max(data$arrival_rate2)\n\n  while(TRUE){\n    # get time bucket (row of dataframe to use)\n    t &lt;- floor(simulation_time / interval) %% nrow(data) + 1\n    lambda_t &lt;- data$arrival_rate2[t]\n    \n    # set to a large number so that at least 1 sample is taken\n    u &lt;- Inf\n    rejects &lt;- -1\n    \n    # running total of time until next arrival\n    inter_arrival_time &lt;- 0.0\n    \n    # reject proportionate to lambda_t / lambda_max\n    ratio &lt;- lambda_t / lambda_max\n    while(u &gt;= ratio){\n      rejects &lt;- rejects + 1\n      # sample using max arrival rate\n      inter_arrival_time &lt;- inter_arrival_time + rexp(1, lambda_max)\n      u &lt;- runif(1, 0.0, 1.0)\n    }\n    \n    if(debug){\n      print({paste(\"Time:\", simulation_time, \n                   \" Rejections:\", rejects, \n                   \" t:\", t, \n                   \" lambda_t:\", lambda_t, \n                   \" IAT:\", inter_arrival_time)})\n    }\n      \n    return(inter_arrival_time)\n  }\n}"
  },
  {
    "objectID": "02_model/01_model.html#model-parameterisation",
    "href": "02_model/01_model.html#model-parameterisation",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "4. Model parameterisation",
    "text": "4. Model parameterisation\nThe model is setup to be created from a set of functions that return trajectories. Each function accepts a list that contains all parameters to configure the simulation model. Here we create the list and pre-populate it using default values.\n\ncreate_experiment &lt;- function(n_triage_bays=DEFAULT_N_TRIAGE,\n                              n_reg_clerks=DEFAULT_N_REG,\n                              n_exam_rooms=DEFAULT_N_EXAM,\n                              n_trauma_rooms=DEFAULT_N_TRAUMA,\n                              n_non_trauma_cubicles=DEFAULT_NON_TRAUMA_CUBICLES,\n                              n_trauma_cubicles=DEFAULT_TRAUMA_CUBICLES,\n                              triage_mean=DEFAULT_TRIAGE_MEAN,\n                              stabilisation_mean=DEFAULT_TRAUMA_MEAN,\n                              trauma_treat_params=DEFAULT_TRAUMA_TREATMENT_PARAMS,\n                              reg_params=DEFAULT_REG_PARAMS,\n                              exam_params=DEFAULT_EXAM_PARAMS,\n                              prob_non_trauma_treat=DEFAULT_NON_TRAUMA_TREAT_P,\n                              nontrauma_treat_params=DEFAULT_NON_TRAUMA_TREATMENT_PARAMS,\n                              prob_trauma=DEFAULT_PROB_TRAUMA,\n                              arrival_data_path=NSPP_PATH,\n                              log_level=LOG_LEVEL) {\n  \n  # load arrival data\n  arrival_data &lt;- load_arrival_data(path=arrival_data_path)\n  \n  # create list of parameters\n  experiment &lt;- list(n_triage_bays=n_triage_bays,\n                    n_reg_clerks=n_reg_clerks,\n                    n_exam_rooms=n_exam_rooms,\n                    n_trauma_rooms=n_trauma_rooms,\n                    n_non_trauma_cubicles=n_non_trauma_cubicles,\n                    n_trauma_cubicles=n_trauma_cubicles,\n                    triage_mean=triage_mean,\n                    stabilisation_mean=stabilisation_mean,\n                    trauma_treat_params=trauma_treat_params,\n                    reg_params=reg_params,\n                    exam_params=exam_params,\n                    prob_non_trauma_treat=prob_non_trauma_treat,\n                    nontrauma_treat_params=nontrauma_treat_params,\n                    prob_trauma=prob_trauma,\n                    arrival_data=arrival_data,\n                    log_level=log_level)\n  \n  return(experiment)\n}"
  },
  {
    "objectID": "02_model/01_model.html#patient-trajectories",
    "href": "02_model/01_model.html#patient-trajectories",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "5. Patient Trajectories",
    "text": "5. Patient Trajectories\nThe DES package simmer uses the concept of a trajectory to model a process for a particular patient type. In the urgent care centre example trajectories allow us to model separate trauma and non-trauma processes. Note that different trajectories can share common resources.\nThe simmer terminology for using resources and engaging in activities is easy to read:\n\nseize - queue and take a resource when it is available.\ntimeout - a process delay (e.g. treatment or diagnostics)\nrelease - release a resource.\n\nsimmer also provides a way to set an attribute of the trajectory using set_attribute. This is useful for storing timing information to display in a log: for example when a patient begins waiting for a resource (access via now(env)).\n\nImportant notes:\n\nThe function log_ is used in combination with function() paste to provide a dynamic simulation trace to the R console.\nSampling code should look as follows:\n\ntimeout(task = function() rexp(1, 3.0)) %&gt;%\n\nThe keyword function() must be included for dynamic sampling for each patient. Omitting function() means that it is evaluated once at the time the trajectory is created.\n\n\n\n5.1. Trauma Patients\n\nWe wrap the trajectory in a function called create_trauma_pathway. This allows us to pass an argument exp that can parameterise the trajectory for use in a discrete experiment.\n\n\ncreate_trauma_pathway &lt;- function(exp){\n    \n    trauma_pathway &lt;- trajectory(name=\"trauma_pathway\") %&gt;%\n      set_attribute(\"patient_type\", 1) %&gt;%\n      # log patient arrival\n      log_(function() {paste(\"**Trauma arrival\")}, level=1) %&gt;% \n      \n      # triage \n      set_attribute(\"start_triage_wait\", function() {now(exp$env)}) %&gt;%\n      visit(\"triage_bay\", function() rexp(1, 1/exp$triage_mean)) %&gt;%\n      log_(function() {paste(\"(T) Triage wait time:\",\n                       now(exp$env) - get_attribute(exp$env, \"start_triage_wait\"))},\n           level=1) %&gt;%\n      \n      # request trauma room for stabilization\n      set_attribute(\"start_trauma_room_wait\", function() {now(exp$env)}) %&gt;%\n      visit(\"trauma_room\", function() rexp(1, 1/exp$stabilisation_mean)) %&gt;%\n      log_(function() {paste(\"(T) Trauma room wait time:\",\n                       now(exp$env) - get_attribute(exp$env, \"start_trauma_room_wait\"))},\n           level=1) %&gt;%\n      \n      # request treatment cubicle\n      set_attribute(\"start_trauma_treat_wait\", function() {now(exp$env)}) %&gt;%\n      visit(\"trauma_treat_cubicle\", function() rlnorm(1, exp$trauma_treat_params$mu,\n                                                      exp$trauma_treat_params$sigma)) %&gt;%\n      log_(function() {paste(\"********************(T) Trauma treatment cubicle wait time:\",\n                       now(exp$env) - get_attribute(exp$env, \"start_trauma_treat_wait\"))},\n           level=1) %&gt;% \n    \n      # store the total time in system \n      set_attribute(\"total_time\", \n                    function() {now(exp$env) - get_attribute(exp$env, \"start_triage_wait\")})\n    \n  return(trauma_pathway)\n}\n\n\n\n5.2 Non-trauma patients\n\ncreate_nt_cubicle_treatment &lt;- function(exp){\n\n  nt_cubicle_treatment &lt;- trajectory() %&gt;% \n    log_(function() {paste(\"NT patient requirement treatment\")},\n         level=1) %&gt;% \n    seize(resource=\"nontrauma_treat_cubicle\", amount=1) %&gt;% \n    \n    timeout(task = function() rlnorm(1, exp$nontrauma_treat_params$mu,                                                     exp$nontrauma_treat_params$sigma)) %&gt;%\n    release(resource = \"nontrauma_treat_cubicle\", amount = 1) %&gt;% \n    log_(function() {paste(\"NT treatment complete\")},\n     level=1) %&gt;% \n  return(nt_cubicle_treatment)\n}\n\n\ncreate_non_trauma_pathway &lt;- function(exp){\n  # log messages\n  ARRIVAL_MSG = \"**Non-Trauma arrival**\"\n  TRIAGE_MSG = \"(NT) Triage wait time:\"\n  REG_MSG = \"Reg wait time:\"\n  EXAM_MSG = \"Exam wait time:\"\n  EXIT_MSG = \"NT Total time in system:\"\n  \n  # optional trajectory for proportion of patients that requirement treatment\n  nt_cubicle_treatment &lt;- create_nt_cubicle_treatment(exp)\n  \n  non_trauma_pathway &lt;- trajectory(name=\"non_trauma_pathway\") %&gt;%\n    set_attribute(\"patient_type\", 2) %&gt;%\n    # log non_trauma arrival\n    log_(function() {paste(ARRIVAL_MSG)}, level=1) %&gt;% \n    \n    # store start of waiting time for log calculations\n    set_attribute(\"start_triage_wait\", function() {now(exp$env)}) %&gt;%\n    # queue and use triage bay\n    visit(\"triage_bay\", function() rexp(1, 1/exp$triage_mean)) %&gt;%\n    log_(function() {paste(TRIAGE_MSG, now(exp$env) - get_attribute(exp$env, \"start_triage_wait\"))},\n         level=1) %&gt;%\n    \n    # queue and use registration clerk\n    set_attribute(\"start_reg_wait\", function() {now(exp$env)}) %&gt;%\n    visit(\"registration_clerk\", function() rlnorm(1, exp$reg_params$mu, \n                                                  exp$reg_params$sigma)) %&gt;%\n    log_(function() {paste(REG_MSG, now(exp$env) - get_attribute(exp$env, \"start_reg_wait\"))},\n         level=1) %&gt;%\n    \n    # queue and use examination room\n    set_attribute(\"start_exam_wait\", function() {now(exp$env)}) %&gt;%\n    visit(\"examination_room\",  function() rnorm(1, exp$exam_params$mean, \n                                                sqrt(exp$exam_params$var))) %&gt;%\n    log_(function() {paste(EXAM_MSG, now(exp$env) - get_attribute(exp$env, \"start_exam_wait\"))},\n         level=1) %&gt;%\n    \n    # a Proportion of patients require treatment in a cubicle\n    branch (\n      function() sample_nt_trauma_treatment(exp$prob_non_trauma_treat), continue=T,\n      nt_cubicle_treatment\n    ) %&gt;% \n    log_(function() {paste(EXIT_MSG, now(exp$env) - get_attribute(exp$env, \"start_triage_wait\"))},\n         level=1) %&gt;% \n    # store the total time in system \n    set_attribute(\"total_time\", \n                    function() {now(exp$env) - get_attribute(exp$env, \"start_triage_wait\")})\n  \n  return(non_trauma_pathway)\n}"
  },
  {
    "objectID": "02_model/01_model.html#modelling-patient-arrivals",
    "href": "02_model/01_model.html#modelling-patient-arrivals",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "6. Modelling patient arrivals",
    "text": "6. Modelling patient arrivals\nPatients arrive a the urgent treatment centre following a time dependent process. When patients arrive they are classified as trauma or non-trauma.\nTo modify the classification of patients we will use a trajectory that uses the `branch` function from simmer.\nThe function `sample_arrival_type` returns a 1 (trauma) or 2 (non-trauma). This is used to select the appropriate patient trajectory.\n\ncreate_arrival_generator &lt;- function(exp){\n  \n  DEPART_MSG &lt;- \"A patient has departed the UTC\"\n  \n  # create and parameterise the trauma pathway trajectory\n  trauma_pathway &lt;- create_trauma_pathway(exp)\n  \n  # create and parameterise the non-trauma pathway trajectory\n  non_trauma_pathway &lt;- create_non_trauma_pathway(exp)\n  \n  patient_arrival &lt;- trajectory() %&gt;%\n    branch(\n      function() sample_arrival_type(exp$prob_trauma), continue=T,\n        trauma_pathway,\n        non_trauma_pathway\n    ) %&gt;%\n    log_(function() {paste(DEPART_MSG)},level=1) %&gt;% \n    set_attribute(\"departed\", 1)\n  \n  return(patient_arrival)\n}"
  },
  {
    "objectID": "02_model/01_model.html#single-run-of-the-model",
    "href": "02_model/01_model.html#single-run-of-the-model",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "7. Single run of the model",
    "text": "7. Single run of the model\n\nWork in progress\n\n\nsingle_run &lt;- function(env, exp, \n                       rep_number=1, \n                       run_length=DEFAULT_RESULTS_COLLECTION_PERIOD, \n                       debug_arrivals=FALSE){\n  # add the simmer environment to the experiment list.\n  exp &lt;- c(exp, env=env) \n  \n  # Create the arrivals generator\n  arrival_gen &lt;- create_arrival_generator(exp)\n  \n  # create model and run.\n  env %&gt;% \n    add_resource(\"triage_bay\", exp$n_triage_bays) %&gt;%\n    add_resource(\"registration_clerk\", exp$n_reg_clerks) %&gt;%\n    add_resource(\"examination_room\", exp$n_exam_rooms) %&gt;%\n    add_resource(\"trauma_room\", exp$n_trauma_rooms) %&gt;%\n    add_resource(\"trauma_treat_cubicle\", exp$n_trauma_cubicles) %&gt;%\n    add_resource(\"nontrauma_treat_cubicle\", exp$n_non_trauma_cubicles) %&gt;%\n    add_generator(\"Patient\", arrival_gen, \n                  function() nspp_thinning(now(env), exp$arrival_data, \n                                           debug=debug_arrivals),\n                  mon=2) %&gt;% \n    run(until=run_length)\n  \n  # return environment and all of its results.\n  return(env)\n}\n\nScript to conduct single run of the model\n\nNote that the environment is created outside of the single_run function. This is to separate the creation of the environment from the run function call. The reason is so that the now(env) function will work correctly in the nspp_thinning sampling function (if we do not separate then the same time is always passed to the function).\n\n\nset.seed(SEED)\nexp &lt;- create_experiment(log_level=0)\ntreat_sim &lt;- simmer(\"TreatSim\", log_level=exp$log_level)\ntreat_sim &lt;- single_run(treat_sim, exp)\nprint(\"Simulation Complete.\")\n\n[1] \"Simulation Complete.\""
  },
  {
    "objectID": "02_model/01_model.html#multiple-replications",
    "href": "02_model/01_model.html#multiple-replications",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "8. Multiple replications",
    "text": "8. Multiple replications\n\nN_REPS &lt;- 50\n\nset.seed(42)\n\n# note unlike in simmer documentation we use a traditional for loop\n# instead of lapply. This allows us to separate env creation\n# from run and preserve the environment interaction between NSPP \n# and current sim time.\n# TO DO: look again -&gt; can treat_sim be created inside single_run()\nprint(\"running replications...\")\n\n[1] \"running replications...\"\n\nreps = vector()\nfor(rep in 1:N_REPS){\n  exp &lt;- create_experiment(log_level=0)\n  treat_sim &lt;- simmer(\"TreatSim\", log_level=exp$log_level)\n  treat_sim &lt;- single_run(treat_sim, exp)\n  # store the latest simulation enviornment and its results.\n  reps &lt;- c(reps, treat_sim)\n}\nprint(\"Complete.\")\n\n[1] \"Complete.\""
  },
  {
    "objectID": "02_model/01_model.html#results-analysis",
    "href": "02_model/01_model.html#results-analysis",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "9. Results analysis",
    "text": "9. Results analysis\nAnalysis of simmer results is achieved using a mix of statistics collected automatically and custom attributes set by the modeller during the run.\nIn general, we follow a typical strategy in a simulation study. We calculate the mean Key Performance Indicator (KPI) seen during an individual replication of the model (e.g. waiting time for triage and utilisation of the the triage rooms). This is repeated for all replications and the distribution of results can be visualised or we use a summary measure such as the mean.\nBelow we construct a summary table of results providing the mean of 16 KPIs.\n\nCode quality is a work in progress. 😃\n\n\narrivals_by_replication &lt;- function(envs){\n  results &lt;- vector()\n  for(env in envs){\n    results &lt;- c(results, get_n_generated(env, \"Patient\"))\n  }\n  return(data.frame(results))\n}\n\n\nget_resource_counts &lt;- function(exp) {\n  resource = c(\"triage_bay\", \n                \"registration_clerk\", \n                \"examination_room\",\n                \"trauma_room\",\n                \"trauma_treat_cubicle\",\n                \"nontrauma_treat_cubicle\")\n  \n  resource_counts = c(exp$n_triage_bays,\n                      exp$n_reg_clerks,\n                      exp$n_exam_rooms,\n                      exp$n_trauma_rooms,\n                      exp$n_trauma_cubicles,\n                      exp$n_non_trauma_cubicles)\n  \n  df_resource &lt;- data.frame(resource)\n  df_resource$count &lt;- resource_counts\n  return(df_resource)\n}\n\nFunctions to calculate KPIs from custom attributes\n\n# mean time in the system and throughput\ncalc_kpi_from_attributes_for_rep &lt;- function(rep){\n  \n  # get attributes\n  att &lt;- get_mon_attributes(reps)\n  # for speed - limit to replication number.\n  rep_att &lt;- subset(att[att$replication == rep,], select = c(name, key, value))\n  # long to wide format...\n  data_wide &lt;- spread(rep_att, key, value)\n  \n  # Patient type 1: trauma\n  # take the mean and ignore patients still in pathway\n  mean_time_1 = mean(data_wide[data_wide$patient_type == 1,]$total_time, na.rm = TRUE)\n  \n  # Patient type 2: non_trauma\n  # take the mean and ignore patients still in pathway\n  mean_time_2 = mean(data_wide[data_wide$patient_type == 2,]$total_time, na.rm = TRUE)\n  \n  # Throughput - discharges during opening hours.\n  throughput &lt;- sum(data_wide$departed, na.rm=TRUE)\n  \n  # store and return data.frame of results\n  rep_results &lt;- data.frame(\"05_total_time(non-trauma)\" = mean_time_2,\n                            \"08_total_time(trauma)\" = mean_time_1, \n                            \"09_throughput\"= throughput)\n  return(rep_results)\n}\n\ncalc_kpi_from_attributes &lt;- function(){\n  # calcs total time by patient type and total throughput\n  \n  # empty dataframe for attribute calculations.\n  att_results &lt;- data.frame(matrix(ncol = 3, nrow = 0))\n  colnames(att_results) &lt;- c(\"05_total_time(non-trauma)\", \"08_total_time(trauma)\", \"09_throughput\")\n\n  # add each rep separately as this works faster with pivot\n  for(rep in 1:N_REPS){\n    att_results &lt;- rbind(att_results, calc_kpi_from_attributes_for_rep(rep))\n  }\n\n  # return the KPIs by replications\n  return(att_results)\n}\n\n\ncreate_summary_table &lt;- function(reps, exp, dp=2){\n\n  # mean number of arrivals\n  arrival_counts &lt;- arrivals_by_replication(reps)\n  mean_arrivals &lt;- mean(arrival_counts$results)\n  arrival_df &lt;- data.frame(\"00_arrivals\", mean_arrivals)\n  names(arrival_df)&lt;-c(\"kpi\",\"mean\")\n\n  \n  # get results dataframe broken down by resource and replication.\n  arrivals &lt;- get_mon_arrivals(reps, per_resource=TRUE)\n  \n  # calculate waiting time\n  arrivals$waiting_time &lt;-arrivals$end_time - arrivals$start_time - arrivals$activity_time\n  # arrivals$waiting_time &lt;- round(arrivals$waiting_time, 2)\n  \n  cols &lt;- c(\"resource\", \"replication\")\n  summary_wait &lt;- arrivals %&gt;%\n    # mean waiting time in each replication\n    group_by(across(all_of(cols))) %&gt;%\n    summarise(rep_waiting_time=mean(waiting_time)) %&gt;% \n    # mean waiting time across replications\n    group_by(resource) %&gt;% \n    summarise(mean=mean(rep_waiting_time)) %&gt;% \n    mutate(resource=recode(resource,  \n                         'triage_bay'='01a_triage_wait', \n                         'registration_clerk'='02a_registration_wait',\n                         'examination_room'='03a_examination_wait',\n                         'nontrauma_treat_cubicle'='04a_treatment_wait(non_trauma)',\n                         'trauma_room'='06a_stabilisation_wait',\n                         'trauma_treat_cubicle'='07a_treatment_wait(trauma)')) %&gt;% \n    arrange(resource)\n  \n  \n  names(summary_wait)&lt;-c(\"kpi\",\"mean\")\n  \n  # utilisation calculation:\n  # simple calculation of total busy time / total scheduled resource time.\n  # where total scheduled time = n_resource * results collection period.\n  summary_util &lt;- arrivals %&gt;%\n    # mean waiting time in each replication\n    group_by(across(all_of(cols))) %&gt;%\n    summarise(in_use=sum(activity_time)) %&gt;% \n    arrange(resource)\n  \n  # add resource counts to table for calc\n  summary_util &lt;- merge(summary_util, get_resource_counts(exp), \n                        by=\"resource\", all=TRUE)\n  \n  # total in use / total scheduled time\n  summary_util$util = summary_util$in_use / (DEFAULT_RESULTS_COLLECTION_PERIOD * summary_util$count)  \n  \n  summary_util &lt;- summary_util %&gt;%\n    # mean waiting time in each replication\n    group_by(resource) %&gt;%\n    summarise(mean=mean(util)) %&gt;% \n    mutate(resource=recode(resource,  \n                         'triage_bay'='01b_triage_util', \n                         'registration_clerk'='02b_registration_util',\n                         'examination_room'='03b_examination_util',\n                         'nontrauma_treat_cubicle'='04b_treatment_util(non_trauma)',\n                         'trauma_room'='06b_stabilisation_util',\n                         'trauma_treat_cubicle'='07b_treatment_util(trauma)')) %&gt;% \n    arrange(resource)\n\n  names(summary_util) &lt;- c(\"kpi\",\"mean\")\n  \n  overall &lt;- bind_rows(arrival_df, summary_wait, summary_util) %&gt;% \n    arrange(kpi) \n  \n  ## KPIs calculated from attributes\n  # empty dataframe for attribute calculations.\n  att_results &lt;- calc_kpi_from_attributes()\n  mean_att_results &lt;- colMeans(att_results)\n\n  overall &lt;- overall %&gt;%\n    add_row(kpi=\"05_total_time(non-trauma)\", mean=mean_att_results[1]) %&gt;%\n    add_row(kpi=\"08_total_time(trauma)\", mean=mean_att_results[2]) %&gt;%\n    add_row(kpi=\"09_throughput\", mean=mean_att_results[3]) %&gt;%\n    arrange(kpi)\n  \n  # round and return\n  overall$mean &lt;- round(overall$mean, dp)\n  return(overall)\n}\n\n\nresults_summary &lt;- create_summary_table(reps, exp)\nresults_summary\n\n                              kpi   mean\n1                     00_arrivals 230.48\n2                 01a_triage_wait  34.05\n3                 01b_triage_util   0.60\n4           02a_registration_wait 107.45\n5           02b_registration_util   0.84\n6            03a_examination_wait  23.92\n7            03b_examination_util   0.84\n8  04a_treatment_wait(non_trauma) 139.57\n9  04b_treatment_util(non_trauma)   0.87\n10      05_total_time(non-trauma) 236.96\n11         06a_stabilisation_wait   0.00\n12         06b_stabilisation_util   0.00\n13     07a_treatment_wait(trauma)  53.18\n14     07b_treatment_util(trauma)   0.65\n15          08_total_time(trauma) 197.52\n16                  09_throughput 168.54"
  }
]