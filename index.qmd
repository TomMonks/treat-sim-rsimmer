---
title: "Treatment Sim: an R `simmer` implementation"
author: "Thomas Monks, Alison Harper"
format: html
editor: visual
---

## 1. Imports

> Note: help with install of `simmer.plot` (`igraph` installation is the actual issue) on Linux based systems: <https://r.igraph.org/articles/installation-troubleshooting#cannot-compile-igraph-from-sources-on-linux>
>
> > If you make use of conda environments (via Anaconda/mini-conda/mini-forge/mamba), **remember** to `conda deactivate` before installation.

```{r}
library(simmer)
library(simmer.bricks)
suppressMessages(library(simmer.plot))
library(tibble)
library(ggplot2)
suppressMessages(library(RCurl))
suppressMessages(library(Rlab))

```

## 2. Default values and constants

### 2.1 Distribution parameters

```{r}
#' Mean and Variance of the underlying Normal Distribution
#' 
#' @description
#' `normal_moments_from_lognormal` calculates the mu and sigma
#' of the normal distribution underlying a lognormal
#' mean and standard 
#'
#' @details
#' `rlnorm` from `stats` is designed to sample from the lognormal distribution. 
#' The parameters is expects are moments of the underlying normal distribution
#' Using sample mean and standard deviation this function calculates 
#' the mu and sigma of the normal distribution. source: https://blogs.sas.com/content/iml/2014/06/04/simulate-lognormal-data-with-specified-mean-and-variance.html
#' 
#' @param mean A number. Sample mean.
#' @param stdev A number. Sample standard deviation
#' @returns A list 
normal_moments_from_lognormal <- function(mean, std){
  phi <- sqrt(std^2 + mean^2)
  mu <- log(mean**2/phi)
  sigma <- sqrt(log(phi^2/mean^2))
  return(list("mu" = mu, "sigma" = sigma))
}
```

```{r}
# sign-in/triage parameters
DEFAULT_TRIAGE_MEAN <- 3.0

# registration parameters (lognormal distribution)
DEFAULT_REG_PARAMS <- normal_moments_from_lognormal(5.0, sqrt(2.0))

# examination parameters
DEFAULT_EXAM_PARAMS = list(mean=16.0, var=3.0)

# trauma/stabilisation
DEFAULT_TRAUMA_MEAN <- 90.0

# Trauma treatment (lognormal distribution)
DEFAULT_TRAUMA_TREATMENT_PARAMS <- normal_moments_from_lognormal(30.0, sqrt(4.0))

# Non trauma treatment (lognormal distribution)
DEFAULT_NON_TRAUMA_TREATMENT_PARAMS <- normal_moments_from_lognormal(13.3, sqrt(2.0))

# prob patient requires treatment given trauma
DEFAULT_NON_TRAUMA_TREAT_P <- 0.60

# proportion of patients triaged as trauma
DEFAULT_PROB_TRAUMA <- 0.12
```

### 2.2 Time dependent arrival rate data

The data for arrival rates varies between clinic opening at 6am and closure at 12am.

```{r}
# data are held in the Github repo and loaded from there.
NSPP_PATH = 'https://raw.githubusercontent.com/TomMonks/open-science-for-sim/main/src/notebooks/01_foss_sim/data/ed_arrivals.csv'

csv_data <- getURL(NSPP_PATH)
df <- read.csv(text=csv_data)

# lock in order of time of day for bar chart display
df$period <- factor(df$period, levels = df$period)

ggplot(data=df, aes(x=period, y=arrival_rate)) +
  geom_bar(stat="identity", fill="steelblue") + 
  theme(axis.text.x = element_text(angle = 90, 
                                   vjust = 0.5, 
                                   hjust=1)) +
  xlab("Hour of day") + 
  ylab("Mean arrivals (patients/hr)")

```

### 2.3 Resource Counts

Integer count variables representing the number of resources at each activity in the process

```{r}
DEFAULT_N_TRIAGE <- 1
DEFAULT_N_REG <- 1
DEFAULT_N_EXAM <- 3
DEFAULT_N_TRAUMA <- 2

# Non-trauma cubicles
DEFAULT_NON_TRAUMA_CUBICLES <- 1

# trauma pathway cubicles
DEFAULT_TRAUMA_CUBICLES <- 1
```

### 2.4 Simulation model run settings

```{r}
# Random seed - this will be investigated for CRN
SEED <- 42

# default results collection period
DEFAULT_RESULTS_COLLECTION_PERIOD <- 60 * 19

# number of replications.
DEFAULT_N_REPS <- 5

# Show the a trace of simulated events
# 1 = show, 0 = do not show.
LOG_LEVEL <- 1
```

## 3. Functions

```{r}
#' Sample a patient type
#' 
#' @description
#' `sample_arrival_type` samples if a patient type is trauma or non-trauma
#' with a given probability.
#'
#' @details
#' The function uses the Bernouli distribution (Rlab) to sample
#' if a patient is Trauma or Non-Trauma.  The return values are 
#' 1 = Trauma, 2 = Non-trauma.
#' @param p A number: the probability a patient has trauma on arrival
sample_arrival_type <- function(p){
  ifelse(rbern(1, prob = DEFAULT_PROB_TRAUMA) == 1, 1, 2)
}
```

```{r}
#' Sample a if a non-trauma patient requires treatment
#' 
#' @description
#' `sample_nt_trauma_treatment` samples if a non-trauma patient
#' requires cubicle treatment
#'
#' @details
#' The function uses the Bernouli distribution (Rlab) to sample
#' if a patient is requires treatment or not.  The return values are 
#' 1 = Treatment, 0 = No treatment
#' @param p A number: The probability the patient requires treatment
sample_nt_trauma_treatment <- function(p){
  ifelse(rbern(1, prob = p) == 1, 1, 0)
}
```

## 4. Model parameterisation

The model is setup to be created from a set of functions that return trajectories. Each function accepts a list that contains all parameters to configure the simulation model. Here we create the list and pre-populate it using default values.

```{r}
create_experiment <- function(n_triage_bays=DEFAULT_N_TRIAGE,
                              n_reg_clerks=DEFAULT_N_REG,
                              n_exam_rooms=DEFAULT_N_EXAM,
                              n_trauma_rooms=DEFAULT_N_TRAUMA,
                              n_non_trauma_cubicles=DEFAULT_NON_TRAUMA_CUBICLES,
                              n_trauma_cubicles=DEFAULT_TRAUMA_CUBICLES,
                              triage_mean=DEFAULT_TRIAGE_MEAN,
                              stabilisation_mean=DEFAULT_TRAUMA_MEAN,
                              trauma_treat_params=DEFAULT_TRAUMA_TREATMENT_PARAMS,
                              reg_params=DEFAULT_REG_PARAMS,
                              exam_params=DEFAULT_EXAM_PARAMS,
                              prob_non_trauma_treat=DEFAULT_NON_TRAUMA_TREAT_P,
                              prob_trauma=DEFAULT_PROB_TRAUMA,
                              log_level=LOG_LEVEL) {
  
  experiment = list(n_triage_bays=n_triage_bays,
                    n_reg_clerks=n_reg_clerks,
                    n_exam_rooms=n_exam_rooms,
                    n_trauma_rooms=n_trauma_rooms,
                    n_non_trauma_cubicles=n_non_trauma_cubicles,
                    n_trauma_cubicles=n_trauma_cubicles,
                    triage_mean=triage_mean,
                    stabilisation_mean=stabilisation_mean,
                    trauma_treat_params=trauma_treat_params,
                    reg_params=reg_params,
                    exam_params=exam_params,
                    prob_non_trauma_treat=prob_non_trauma_treat,
                    prob_trauma=prob_trauma,
                    log_level=log_level)
  
  return(experiment)
}     
```

## 5. Patient Trajectories

The DES package `simmer` uses the concept of a `trajectory` to model a process for a particular patient type. In the urgent care centre example trajectories allow us to model separate trauma and non-trauma processes. Note that different trajectories can share common resources.

The `simmer` terminology for using resources and engaging in activities is easy to read:

-   `seize` - queue and take a resource when it is available.

-   `timeout` - a process delay (e.g. treatment or diagnostics)

-   `release` - release a resource.

`simmer` also provides a way to set an attribute of the `trajectory` using `set_attribute`. This is useful for storing timing information to display in a log: for example when a patient begins waiting for a resource (access via `now(env)`).

> **Important notes:**
>
> 1.  The function `log_` is used in combination with `function()` `paste` to provide a dynamic simulation trace to the R console.
> 2.  Sampling code should look as follows:
>
> ``` r
> timeout(task = function() rexp(1, 3.0)) %>%
> ```
>
> > The keyword `function()` must be included for dynamic sampling for each patient. **Omitting** `function()` means that it is evaluated **once** at the time the `trajectory` is created.

### 5.1. Trauma Patients

> We wrap the trajectory in a function called `create_trauma_pathway`. This allows us to pass an argument `exp` that can parameterise the trajectory for use in a discrete experiment.

```{r}

create_trauma_pathway <- function(exp){

    trauma_pathway <- trajectory(name="trauma_pathway") %>%
    # log patient arrival
    log_(function() {paste("**Trauma arrival")}, level=1) %>% 
    
    # triage 
    set_attribute("start_triage_wait", function() {now(exp$env)}) %>%
    visit("triage_bay", function() rexp(1, exp$triage_mean)) %>%
    log_(function() {paste("(T) Triage wait time:",
                     now(exp$env) - get_attribute(exp$env, "start_triage_wait"))},
         level=1) %>%
    
    # request trauma room for stabilization
    set_attribute("start_trauma_room_wait", function() {now(exp$env)}) %>%
    visit("trauma_room", function() rexp(1, exp$stabilisation_mean)) %>%
    log_(function() {paste("(T) Trauma room wait time:",
                     now(exp$env) - get_attribute(exp$env, "start_trauma_room_wait"))},
         level=1) %>%
    
    # request treatment cubicle
    visit("trauma_treat_cubicle", function() rlnorm(1, exp$trauma_treat_params$mu,
                                                    exp$trauma_treat_params$sigma)) %>%
  
  return(trauma_pathway)
}
```

### 5.2 Non-trauma patients

```{r}
nt_cubicle_treatment <- trajectory() %>% 
  log_(function() {paste("NT patient requirement treatment")},
       level=1) %>% 
  seize(resource="nontrauma_treat_cubicle", amount=1) %>% 
  timeout(task = rlnorm(1, meanlog=13.3, sdlog=sqrt(2.0))) %>%
  release(resource = "nontrauma_treat_cubicle", amount = 1)
```

```{r}

create_non_trauma_pathway <- function(exp){
  # log messages
  ARRIVAL_MSG = "**Non-Trauma arrival**"
  TRIAGE_MSG = "(NT) Triage wait time:"
  REG_MSG = "Reg wait time:"
  EXAM_MSG = "Exam wait time:"
  EXIT_MSG = "NT Total time in system:"
  
  non_trauma_pathway <- trajectory(name="non_trauma_pathway") %>%
    # log non_trauma arrival
    log_(function() {paste(ARRIVAL_MSG)}, level=1) %>% 
    
    # store start of waiting time for log calculations
    set_attribute("start_triage_wait", function() {now(exp$env)}) %>%
    # queue and use triage bay
    visit("triage_bay", function() rexp(1, exp$triage_mean)) %>%
    log_(function() {paste(TRIAGE_MSG, now(exp$env) - get_attribute(exp$env, "start_triage_wait"))},
         level=1) %>%
    
    # queue and use registration clerk
    set_attribute("start_reg_wait", function() {now(exp$env)}) %>%
    visit("registration_clerk", function() rlnorm(1, exp$reg_params$mu, 
                                                  exp$reg_params$sigma)) %>%
    log_(function() {paste(REG_MSG, now(exp$env) - get_attribute(exp$env, "start_reg_wait"))},
         level=1) %>%
    
    # queue and use examination room
    set_attribute("start_exam_wait", function() {now(exp$env)}) %>%
    visit("examination_room",  function() rnorm(1, exp$exam_params$mean, 
                                                sqrt(exp$exam_params$var))) %>%
    log_(function() {paste(EXAM_MSG, now(exp$env) - get_attribute(exp$env, "start_exam_wait"))},
         level=1) %>%
    
    # a Proportion of patients require treatment in a cubicle
    branch (
      function() sample_nt_trauma_treatment(exp$prob_non_trauma_treat), continue=T,
      nt_cubicle_treatment
    ) %>% 
    log_(function() {paste(EXIT_MSG, now(exp$env) - get_attribute(exp$env, "start_triage_wait"))},
         level=1)
  
  return(non_trauma_pathway)
}
```

## 6. Modelling patient arrivals

Patients arrive a the urgent treatment centre following a time dependent process. When patients arrive they are classified as trauma or non-trauma.

To modify the classification of patients we will use a trajectory that uses the \`branch\` function from `simmer`.

The function \`sample_arrival_type\` returns a 1 (trauma) or 2 (non-trauma). This is used to select the appropriate patient trajectory.

```{r}

create_arrival_generator <- function(exp){
  
  DEPART_MSG <- "A patient has departed the UTC"
  
  # create and parameterise the trauma pathway trajectory
  trauma_pathway <- create_trauma_pathway(exp)
  
  # create and parameterise the non-trauma pathway trajectory
  non_trauma_pathway <- create_non_trauma_pathway(exp)
  
  patient_arrival <- trajectory() %>%
    branch(
      function() sample_arrival_type(exp$prob_trauma), continue=T,
        trauma_pathway,
        non_trauma_pathway
    ) %>%
    log_(function() {paste(DEPART_MSG)},level=1)
  
  return(patient_arrival)
}
```

## 7. Single run of the model

> Work in progress: model is still missing non-trauma logic + time dependent arrival rate via thinning.

```{r}
set.seed(SEED)

get_model <- function(exp){
  
  arrival_gen <- create_arrival_generator(exp)
  
  env <- simmer("TreatSim", log_level=exp$log_level) %>% 
    add_resource("triage_bay", exp$n_triage_bays) %>%
    add_resource("registration_clerk", exp$n_reg_clerks) %>%
    add_resource("examination_room", exp$n_exam_rooms) %>%
    add_resource("trauma_room", exp$n_trauma_rooms) %>%
    add_resource("trauma_treat_cubicle", exp$n_trauma_cubicles) %>%
    add_resource("nontrauma_treat_cubicle", exp$n_non_trauma_cubicles) %>%
    add_generator("Patient", arrival_gen, function() rexp(1, 1.0/10.0))
  
  # add the simmer environment to the experiment list.
  exp <- c(exp, env=env)
  
  return(env)
}
```

```{r}
default_experiment <- create_experiment(log_level=0)
treat_sim <- get_model(default_experiment)

treat_sim %>% 
  run(until=400) %>% 
  invisible
```

## 8. Results

```{r}
resources <- get_mon_resources(treat_sim)
plot(resources, metric = "usage", c("triage_bay", "trauma_room"), items = "server")

```

You can add options to executable code like this

```{r}
#| echo: false
2 * 2
```

The `echo: false` option disables the printing of code (only output is displayed).
